**Вопрос 1**

Параметризованные типы, также известные как обобщения, позволяют объявлять классы, интерфейсы и методы, в которых тип данных указывается в виде параметра[7][8]. Использование параметризованных типов обеспечивает типовую безопасность[1][10].

**Создание параметризованных классов**
1.  **Объявление:** Параметризованный класс объявляется так же, как и обычный класс, но с добавлением раздела параметров типа после имени класса[6]. Раздел параметров типа состоит из одного или нескольких параметров типа, разделенных запятыми[6].
    ```java
    class ИмяКласса<T> {
        // ...
    }
    ```
2.  **Параметры типа:** В угловых скобках `<>` указывается имя параметра типа, которое используется в качестве заполнителя для реального типа, передаваемого классу при создании экземпляра[8].
3.  **Использование:** Внутри класса параметр типа может использоваться для объявления переменных, параметров методов и возвращаемых типов[7].
    ```java
    class Generics<T> {
        T ob;
        Generics(T o) {
            ob = o;
        }
        T getObject() {
            return ob;
        }
    }
    ```
4.  **Инстанцирование:** При создании экземпляра параметризованного класса необходимо указать конкретный тип данных, который будет использоваться[7].
    ```java
    Generics<Integer> iObject = new Generics<>(777);
    Generics<String> strOb = new Generics<>("Обобщенный текст");
    ```
5.  **Примеры параметризованных классов**:
    *   Очередь (Queue): параметризованная очередь, работающая с любыми типами данных[9].
    *   Хранилище (Storage): универсальное хранилище элементов любого типа[9].
    *   Пара (Pair): способ хранения двух связанных переменных разных типов[9].

Параметризованные классы могут быть частью иерархии классов, выступая в качестве суперкласса или подкласса[7]. В параметризованной иерархии любые аргументы типов, необходимые параметризованному суперклассу, должны передаваться всеми подклассами по иерархии вверх[7].

**Вопрос 2**

Параметризованные методы позволяют использовать один и тот же метод с разными типами данных[3][5]. Ограничения типов позволяют указать, какие типы данных могут быть использованы в параметризованных методах[5]. Вы интересуетесь объектно-ориентированным программированием, особенно параметризованными классами и ограничениями типов[9].

**Работа с параметризованными методами**

1.  **Объявление:** Параметризованные методы объявляются с использованием раздела параметров типа перед типом возвращаемого значения[5].
    ```java
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    ```
2.  **Вызов:** При вызове параметризованного метода тип можно указать явно или позволить компилятору вывести его[6].
    ```java
    printArray(intArray); // Выведет: 1 2 3
    printArray(strArray); // Выведет: Hello World
    ```

**Ограничение типа сверху**

1.  **Ключевое слово `extends`:** Ограничение сверху указывает, что тип должен быть подклассом указанного класса или интерфейса[5].
    ```java
    public static <T extends Number> byte asByte(T num) {
        long n = num.longValue();
        if (n >= -128 && n <= 127) return (byte)n;
        else return 0;
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть подклассом класса `Number`[5]. Это позволяет использовать метод `doubleValue()` для преобразования значения объектов типа `T` в тип `double`[6].

**Ограничение типа снизу**

1.  **Ключевое слово `super`:** Ограничение снизу указывает, что тип должен быть суперклассом указанного класса[5].
    ```java
    public static <T super Integer> void processElements(List<T> list) {
        // ...
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть суперклассом класса `Integer`. Это позволяет методу работать со списками, которые могут содержать `Integer` или его суперклассы.


**Вопрос 3**

Класс **Number** в Java — это абстрактный суперкласс для всех числовых классов-оберток, таких как Integer, Double, Float, Long, Byte и Short. Он определяет методы для преобразования числовых значений в разные примитивные типы: `byteValue()`, `doubleValue()`, `floatValue()`, `intValue()`, `longValue()`, `shortValue()`[2].

**Классы-обертки (Wrappers)** — это классы, которые "оборачивают" примитивные типы данных в объекты. Например:
- `Integer` — обертка для `int`
- `Double` — обертка для `double`
- `Character` — обертка для `char`
- `Boolean` — обертка для `boolean`

Эти классы позволяют использовать примитивы там, где необходимы объекты, например, в коллекциях.

**Автоупаковка (autoboxing)** — это автоматическое преобразование примитивного типа в соответствующий объект-обертку. Например, при присваивании значения типа `int` переменной типа `Integer` компилятор автоматически создает объект `Integer`.

```java
Integer i = 5; // автоупаковка int в Integer
```

**Автораспаковка (unboxing)** — обратный процесс, когда объект-обертка автоматически преобразуется в примитивный тип.

```java
int n = i; // автораспаковка Integer в int
```

Таким образом, автоупаковка и автораспаковка упрощают работу с примитивами и объектами, устраняя необходимость явного создания объектов-оберток или вызова методов для получения примитивных значений[2].

Важной особенностью является то, что все классы-обертки наследуются от `Number` (кроме `Character` и `Boolean`, которые не являются числовыми), что позволяет использовать их в обобщениях и методах с ограничениями по типу, например `<T extends Number>`[2][6].

**Вопрос 4**

В Java коллекции представляют собой структуры данных для хранения и управления группами однородных элементов. Основные виды коллекций и их интерфейсы:

## Виды коллекций и основные интерфейсы

- **List**  
  Упорядоченный список элементов, допускающий дубликаты. Каждый элемент имеет индекс. Позволяет получать, добавлять и удалять элементы по индексу.  
  Основные реализации: `ArrayList`, `LinkedList`, `Vector`.  
  Особенности: поддержка итератора `ListIterator`, который умеет перемещаться вперед и назад по списку.  
  [1][2][7]

- **Set**  
  Коллекция уникальных элементов, не допускающая дубликатов. Порядок элементов не гарантируется (в зависимости от реализации).  
  Основные реализации: `HashSet`, `TreeSet`, `LinkedHashSet`.  
  [1][2]

- **Queue**  
  Коллекция, работающая по принципу «первым пришел — первым вышел» (FIFO). Используется для организации очередей.  
  Основные реализации: `LinkedList`, `PriorityQueue`.  
  [1][2]

- **Deque**  
  Расширяет интерфейс `Queue` и представляет двунаправленную очередь, где элементы можно добавлять и удалять с обоих концов.  
  Основные реализации: `ArrayDeque`, `LinkedList`.  
  [2]

- **Map**  
  Коллекция пар «ключ-значение», где ключи уникальны. Не наследуется от `Collection`, но тесно связана с коллекциями.  
  Основные реализации: `HashMap`, `TreeMap`, `LinkedHashMap`.  
  [1][2][5]

## Иерархия и особенности

- Интерфейс `Collection` — базовый для `List`, `Set` и `Queue`.  
- Интерфейс `Iterable` — корневой для всех коллекций, обеспечивает возможность перебора элементов.  
- `Map` не входит в иерархию `Collection`, но является ключевой структурой данных для хранения ассоциативных пар.  
[2][5][6]

## Краткое сравнение

| Интерфейс | Описание                          | Особенности                          | Примеры реализаций          |
|-----------|---------------------------------|------------------------------------|----------------------------|
| List      | Упорядоченный список с дубликатами | Индексированный доступ, дубликаты разрешены | ArrayList, LinkedList, Vector |
| Set       | Множество уникальных элементов   | Нет дубликатов, порядок не гарантируется | HashSet, TreeSet, LinkedHashSet |
| Queue     | Очередь FIFO                    | Добавление в конец, удаление из начала | LinkedList, PriorityQueue   |
| Deque     | Двунаправленная очередь          | Добавление/удаление с обоих концов | ArrayDeque, LinkedList      |
| Map       | Коллекция пар ключ-значение      | Уникальные ключи, быстрый поиск по ключу | HashMap, TreeMap, LinkedHashMap |

Таким образом, выбор коллекции зависит от требований к упорядочиванию, уникальности элементов и способу доступа к данным. Коллекции в Java обеспечивают гибкие и эффективные инструменты для работы с различными структурами данных.  
[1][2][5][6][7]

**Вопрос 5**

Для обхода элементов коллекций в Java используются интерфейсы **Iterable**, **Iterator** и **ListIterator**, которые обеспечивают последовательный доступ к элементам без раскрытия внутренней структуры коллекции.

## Интерфейс Iterable

- Это базовый интерфейс, реализуемый всеми коллекциями, который позволяет получить итератор для обхода элементов.  
- Определяет метод `iterator()`, возвращающий объект типа `Iterator`.  
- Позволяет использовать цикл `for-each` для удобного перебора элементов коллекции.

## Интерфейс Iterator

- Предоставляет методы для последовательного обхода коллекции:  
  - `boolean hasNext()` — проверяет, есть ли следующий элемент;  
  - `E next()` — возвращает следующий элемент;  
  - `void remove()` — удаляет текущий элемент из коллекции (после вызова `next()`).  
- Итератор позволяет безопасно проходить по коллекции, получать и удалять элементы во время обхода.  
- Получается через метод `iterator()` коллекции.  
- Пример использования:
  ```java
  Iterator<String> it = collection.iterator();
  while (it.hasNext()) {
      String element = it.next();
      System.out.println(element);
  }
  ```

## Интерфейс ListIterator

- Расширяет `Iterator` и предназначен для обхода списков (`List`).  
- Добавляет возможность двунаправленной итерации:  
  - `boolean hasPrevious()` и `E previous()` — для движения назад по списку;  
- Позволяет получать индексы элементов:  
  - `int nextIndex()`, `int previousIndex()`;  
- Поддерживает изменение коллекции во время обхода:  
  - `void add(E e)` — вставка элемента;  
  - `void set(E e)` — замена текущего элемента;  
  - `void remove()` — удаление текущего элемента;  
- Получается через метод `listIterator()` списка.  
- Пример двунаправленного обхода:
  ```java
  ListIterator<String> listIt = list.listIterator();
  while (listIt.hasNext()) {
      System.out.println(listIt.next());
  }
  while (listIt.hasPrevious()) {
      System.out.println(listIt.previous());
  }
  ```

Таким образом, интерфейс **Iterable** обеспечивает получение итератора, **Iterator** позволяет последовательно обходить и изменять коллекцию, а **ListIterator** расширяет эти возможности для списков, предоставляя двунаправленную навигацию и дополнительные методы модификации элементов[1][2][3][4][7].

**Вопрос 6**

Для сортировки элементов коллекций в Java используются интерфейсы **Comparable** и **Comparator**, которые задают правила сравнения объектов.

## Интерфейс Comparable

- Определяет естественный порядок сортировки объектов класса.  
- Класс, объекты которого нужно сортировать, должен реализовать интерфейс `Comparable<T>` и переопределить метод:
  ```java
  int compareTo(T o);
  ```
- Метод `compareTo` возвращает отрицательное число, ноль или положительное число, если текущий объект меньше, равен или больше объекта `o`.  
- Пример:
  ```java
  public class Person implements Comparable<Person> {
      private int age;
      @Override
      public int compareTo(Person other) {
          return Integer.compare(this.age, other.age);
      }
  }
  ```
- Используется, когда сортировка всегда должна происходить по одному критерию — "естественному порядку".  
- Коллекции, такие как `TreeSet` и `TreeMap`, требуют реализации `Comparable` для автоматической сортировки элементов[1][2][5].

## Интерфейс Comparator

- Позволяет задавать альтернативные или дополнительные правила сортировки, не изменяя исходный класс.  
- Реализуется в отдельном классе или с помощью лямбда-выражений.  
- Определяет метод:
  ```java
  int compare(T o1, T o2);
  ```
- Позволяет сортировать по разным атрибутам или нескольким критериям, комбинируя компараторы через `thenComparing`.  
- Пример сортировки по имени и отделу:
  ```java
  Collections.sort(students, Comparator.comparing(Student::getDepartment)
                                       .thenComparing(Student::getName));
  ```
- Можно создавать компараторы "на лету" через статический метод `Comparator.comparing()` и использовать методы для обработки `null` и обратного порядка.  
- Обеспечивает гибкость и расширяемость сортировки без изменения класса объектов[1][3][6].

## Итоги и рекомендации

| Особенность               | Comparable                         | Comparator                          |
|--------------------------|----------------------------------|-----------------------------------|
| Где реализуется           | В самом классе                   | В отдельном классе или лямбдами   |
| Количество критериев      | Один (естественный порядок)      | Несколько, комбинируемые          |
| Изменение исходного класса| Требуется                       | Не требуется                      |
| Использование             | Для коллекций с естественным порядком | Для гибкой и многоуровневой сортировки |

Таким образом, если нужна простая сортировка по одному критерию — реализуйте `Comparable`. Если требуется несколько вариантов сортировки или сложная логика — используйте `Comparator`[1][2][3][6].

**Вопрос 7**

Интерфейс **List** в Java представляет собой упорядоченную коллекцию, которая допускает хранение дубликатов и обеспечивает доступ к элементам по индексу. Он расширяет интерфейс **Collection** и добавляет методы для работы с позициями элементов, такие как вставка, замена, сортировка и получение подсписков[3][5][8].

## Интерфейс List

- Хранит элементы в порядке добавления.
- Позволяет обращаться к элементам по индексу.
- Поддерживает дубликаты.
- Основные методы:  
  - `add(int index, E element)` — вставка элемента по индексу;  
  - `set(int index, E element)` — замена элемента по индексу;  
  - `get(int index)` — получение элемента по индексу;  
  - `subList(int start, int end)` — получение подсписка;  
  - `sort(Comparator<? super E> c)` — сортировка списка.

## Класс ArrayList

- Реализация интерфейса List на основе динамического массива.  
- Позволяет быстро получать доступ к элементам по индексу (операция за O(1)).  
- При добавлении элементов в конец может расширять внутренний массив (копирование данных при увеличении размера).  
- Медленнее при вставке и удалении элементов в середине списка, так как требует сдвига элементов.  
- Поддерживает хранение любых ссылочных типов, включая `null`.  
- Часто используется благодаря хорошему балансу производительности и удобству.  
- Конструкторы:  
  - `ArrayList()` — с начальной емкостью 10;  
  - `ArrayList(int initialCapacity)` — с заданной емкостью;  
  - `ArrayList(Collection<? extends E> c)` — создание из другой коллекции[2][3][6].

## Класс LinkedList

- Реализация интерфейса List на основе двусвязного списка.  
- Позволяет эффективно вставлять и удалять элементы в любом месте списка (операции за O(1), если известна позиция).  
- Медленнее при доступе по индексу, так как требует последовательного обхода (операция за O(n)).  
- Также реализует интерфейс Queue и Deque, позволяя использовать его как очередь или двунаправленную очередь.  
- Подходит, когда требуется много вставок и удалений, а быстрый доступ по индексу не критичен[7][8].

## Сравнение ArrayList и LinkedList

| Характеристика           | ArrayList                          | LinkedList                      |
|-------------------------|----------------------------------|--------------------------------|
| Основная структура       | Динамический массив               | Двусвязный список              |
| Доступ по индексу        | Быстрый (O(1))                   | Медленный (O(n))               |
| Вставка/удаление в середине | Медленная (сдвиг элементов)      | Быстрая (перенастройка ссылок)|
| Использование памяти     | Меньше (массив)                  | Больше (узлы с указателями)    |
| Дополнительные интерфейсы| Нет                             | Реализует Queue и Deque        |

## Рекомендации по использованию

- Используйте **ArrayList**, если требуется быстрый доступ по индексу и операции вставки/удаления преимущественно в конце списка.  
- Используйте **LinkedList**, если часто выполняются вставки и удаления в середине коллекции и не важен быстрый доступ по индексу.

## Пример создания и использования ArrayList

```java
List<String> list = new ArrayList<>();
list.add("яблоко");
list.add("банан");
list.add("вишня");
System.out.println(list.get(1)); // банан
```

Таким образом, интерфейс **List** обеспечивает удобную работу с упорядоченными коллекциями, а классы **ArrayList** и **LinkedList** предоставляют разные реализации, оптимизированные под разные сценарии использования[2][3][7][8].



**Вопрос 8**

Интерфейсы **Map** и **SortedMap** в Java представляют коллекции пар «ключ-значение», но отличаются по функциональности и способу хранения данных.

## Интерфейс Map

- Представляет коллекцию пар «ключ-значение», где каждому ключу сопоставлено одно значение.  
- Ключи уникальны, значения могут повторяться.  
- Не наследуется от `Collection`, но является частью Java Collections Framework.  
- Основные методы:  
  - `put(K key, V value)` — добавить или заменить пару;  
  - `get(Object key)` — получить значение по ключу;  
  - `containsKey(Object key)` — проверить наличие ключа;  
  - `remove(Object key)` — удалить пару по ключу;  
  - `entrySet()` — получить набор пар `Map.Entry<K,V>` для перебора.  

## Интерфейс SortedMap

- Расширяет интерфейс `Map`.  
- Гарантирует, что элементы хранятся в отсортированном порядке по ключам (естественный порядок или с помощью `Comparator`).  
- Добавляет методы для работы с диапазонами ключей и навигации:  
  - `firstKey()`, `lastKey()` — получить первый и последний ключ;  
  - `headMap(K toKey)`, `tailMap(K fromKey)`, `subMap(K fromKey, K toKey)` — получить части отображения по диапазонам ключей;  
  - `comparator()` — получить используемый компаратор (или `null`, если используется естественный порядок).  

## Класс HashMap

- Реализация интерфейса `Map` на основе хэш-таблицы.  
- Обеспечивает быстрый доступ, вставку и удаление элементов (в среднем за O(1)).  
- Не гарантирует порядок элементов.  
- Позволяет один `null` ключ и несколько `null` значений.  
- Подходит для большинства задач, где порядок не важен, а нужна высокая производительность.

## Класс TreeMap

- Реализация интерфейса `SortedMap` (а также `NavigableMap`) на основе красно-черного дерева.  
- Хранит элементы в отсортированном порядке по ключам.  
- Операции вставки, удаления и поиска выполняются за O(log n).  
- Требует, чтобы ключи были сравнимы (реализовали `Comparable`) или чтобы при создании передавался `Comparator`.  
- Предоставляет расширенный функционал навигации по ключам: поиск ближайших ключей, удаление первого/последнего элемента и др.  
- Используется, когда важен отсортированный порядок ключей и возможность работы с диапазонами.

## Итоговое сравнение

| Характеристика       | HashMap                         | TreeMap                          |
|---------------------|--------------------------------|---------------------------------|
| Интерфейс           | Map                            | SortedMap, NavigableMap          |
| Структура данных    | Хэш-таблица                    | Красно-черное дерево             |
| Порядок элементов   | Не гарантируется               | Отсортирован по ключам           |
| Сложность операций  | O(1) в среднем                 | O(log n)                        |
| Поддержка null      | Ключ — 1 null, значения — несколько | Ключи null не поддерживаются    |
| Дополнительные методы| Нет                           | Методы работы с диапазонами и навигации по ключам |

Таким образом, **HashMap** — это быстрая и простая реализация для хранения пар без порядка, а **TreeMap** — для случаев, когда важен отсортированный порядок ключей и расширенные возможности навигации.

---



**Вопрос 9**

В Java интерфейсы `Set` и `SortedSet` используются для представления наборов уникальных элементов, при этом `SortedSet` дополнительно обеспечивает их упорядочивание. `HashSet` и `TreeSet` — это классы, реализующие эти интерфейсы[9].

**Интерфейс Set**
*   Представляет собой набор уникальных элементов, не допускающий дублирования[3][4].
*   Не добавляет новых методов, а изменяет унаследованные, например, метод `add()` возвращает `true`, только если элемент еще не содержится в коллекции[3][4].
*   Реализован классами `HashSet`, `TreeSet` и `LinkedHashSet`[9].

**Интерфейс SortedSet**
*   Расширяет интерфейс `Set` и представляет собой упорядоченное множество, элементы которого отсортированы по возрастанию или в соответствии с `Comparator`[6].
*   Содержит методы для работы с упорядоченными данными, такие как `comparator()`, `first()`, `last()`, `headSet()`, `subSet()`, `tailSet()`[6].

**Класс HashSet**
*   Реализует интерфейс `Set` и хранит элементы в хеш-таблице[1][4].
*   Не гарантирует порядок элементов при переборе[1][2].
*   Может хранить `NULL` значения[2].
*   Для создания объекта `HashSet` можно использовать следующие конструкторы[3]:
    *   `HashSet()`: создает пустой список.
    *   `HashSet(Collection<? extends E> col)`: создает хеш-таблицу, добавляя все элементы из указанной коллекции.
    *   `HashSet(int capacity)`: создает хеш-таблицу с указанной начальной емкостью (по умолчанию 16).
    *   `HashSet(int capacity, float koef)`: создает хеш-таблицу с указанной начальной емкостью и коэффициентом заполнения (от 0.0 до 1.0).

**Класс TreeSet**
*   Реализует интерфейс `SortedSet` и хранит элементы в отсортированном порядке[6].
*   Элементы хранятся в отсортированном порядке по возрастанию[6].
*   Операции удаления и вставки выполняются медленнее, чем в `HashSet`, но быстрее, чем в списках[6].
*   Реализует интерфейс `NavigableSet`[8].
*   Конструкторы класса `TreeSet`[6]:
    *   `TreeSet()`
    *   `TreeSet(Collection<? extends Е> сollection)`
    *   `TreeSet(Comparator<? super Е> соmрarator)`
    *   `TreeSet(SortedSet<E> sortedSet)`

Как вы изучаете структуры данных в Java[10], важно понимать, как `HashSet` и `TreeSet` реализуют интерфейсы `Set` и `SortedSet`[9].



**Вопрос 10**

В Java интерфейсы `Queue` и `Deque` являются частью Collections Framework и предоставляют способы хранения и управления элементами в определенном порядке[4][5]. Классы `PriorityQueue` и `ArrayDeque` являются реализациями этих интерфейсов.

**Интерфейс Queue**
*   Представляет собой коллекцию, предназначенную для хранения элементов в порядке "первым пришел — первым вышел" (FIFO)[4][5].
*   Определяет методы для добавления (`add()`, `offer()`), удаления (`remove()`, `poll()`) и просмотра (`element()`, `peek()`) элементов[5][6].
*   `Queue` является однонаправленной очередью, где элементы добавляются в конец, а извлекаются из начала[1].

**Интерфейс Deque**
*   Расширяет интерфейс `Queue` и представляет собой двустороннюю очередь, позволяющую добавлять и удалять элементы с обоих концов[2][4].
*   Поддерживает как FIFO, так и LIFO (стек) операции[4][5].
*   Предоставляет методы для добавления (`addFirst()`, `addLast()`, `offerFirst()`, `offerLast()`), удаления (`removeFirst()`, `removeLast()`, `pollFirst()`, `pollLast()`) и просмотра (`getFirst()`, `getLast()`, `peekFirst()`, `peekLast()`) элементов с обеих сторон[1][5][7].
*   `Deque` не имеет явно выраженного конца и начала и может расти и уменьшаться в обоих направлениях[8].

**Класс PriorityQueue**
*   Реализует интерфейс `Queue`[6].
*   Представляет собой очередь с приоритетами, где элементы упорядочены в соответствии с их приоритетом[6].
*   Основан на структуре данных "двоичная куча", обеспечивающей быструю вставку и удаление элементов за \$$ O(log n) \$$[6].
*   Удаляет элемент с наивысшим приоритетом (наименьший элемент, если не задан компаратор)[6].
*   Для определения приоритета элементов можно использовать `Comparator`[6].

**Класс ArrayDeque**

*   Реализует интерфейс `Deque`[6].
*   Реализован на основе массива, что делает его эффективным для использования в качестве стека или очереди[6].
*   Поддерживает добавление и удаление элементов с обоих концов за константное время[6].
*   `LinkedList` и `ArrayDeque` напрямую наследуют от `Deque`, а не от `Queue`[3].

Поскольку вас интересует объектно-ориентированное программирование и Java [9][10], важно понимать, как эти интерфейсы и классы реализуют принципы полиморфизма и абстракции.

**Вопрос 11**

В Java 21 появились новые интерфейсы для работы с упорядоченными коллекциями: `SequencedCollection` и `SequencedSet`[1][2][3].

**Интерфейс SequencedCollection**
*   Расширяет интерфейс `Collection`, добавляя методы для манипуляции с первым и последним элементами, а также для инвертирования коллекции[1][2][5].
*   Поддерживает операции как в начале, так и в конце списка, и является обратимой[3].
*   Определяет порядок элементов, располагая их линейно от первого до последнего[3].
*   Содержит методы: `addFirst()`, `addLast()`, `getFirst()`, `getLast()`, `removeFirst()`, `removeLast()`, `reversed()`[2].

Реализации `SequencedCollection`:
*   `List` (`ArrayList` и `LinkedList`)[1][2]
*   `Deque`
*   `SequencedSet`[8]

**Интерфейс SequencedSet**
*   Является под интерфейсом `SequencedCollection`[1].
*   Переопределяет метод `reversed()`, возвращая `SequencedSet` вместо `SequencedCollection`[1].

Реализации `SequencedSet`:
*   `LinkedHashSet` (сохраняет порядок добавления)[1]
*   `TreeSet` (сортирует в алфавитном порядке)[1]

**Класс HashSet**
*   Не поддерживает интерфейс `SequencedSet`, так как не обеспечивает порядок[1].

**Класс LinkedHashSet**
*   Реализует интерфейс `SequencedSet` и сохраняет порядок добавления элементов[1].
*   Поддерживает методы `addFirst()` и `addLast()`[1].

**Класс TreeSet**
*   Реализует интерфейс `SequencedSet` и сортирует элементы в алфавитном порядке[1].
*   Не поддерживает методы `addFirst()` и `addLast()`, так как сам определяет порядок элементов[1].
*   Поддерживает удаление первого и последнего элемента[1].

Поскольку вы интересуетесь объектно-ориентированным программированием и Java[9][10], важно понимать, как эти новые интерфейсы расширяют возможности работы с коллекциями, особенно с учетом вашего интереса к интерфейсам и очередям[11].


**Вопрос 12**

В Java классы `Collections`, `Arrays` и `Objects` предоставляют набор статических методов для удобной работы с коллекциями, массивами и объектами соответственно.

## Класс Collections
*   Содержит статические методы для работы с коллекциями (`Collection`, `List`, `Set` и др.).
*   Основные методы:
    *   `addAll(Collection<? super T> c, T... elements)` — добавляет все указанные элементы в коллекцию.
    *   `binarySearch(List<? extends Comparable<? super T>> list, T key)` — выполняет бинарный поиск элемента в отсортированном списке.
    *   `copy(List<? super T> dest, List<? extends T> src)` — копирует элементы из одного списка в другой.
    *   `max(Collection<? extends T> coll)` и `min(Collection<? extends T> coll)` — возвращают максимальный и минимальный элемент коллекции согласно естественному порядку.
    *   `reverse(List<?> list)` — изменяет порядок элементов списка на обратный.
    *   `shuffle(List<?> list)` — случайным образом перемешивает элементы списка.
    *   `sort(List<T> list)` — сортирует список по естественному порядку.
    *   `replaceAll(List<T> list, T oldVal, T newVal)` — заменяет все вхождения одного элемента на другой.
*   Методы работают с интерфейсами коллекций, обеспечивая гибкость и переиспользуемость[3][6].

## Класс Arrays
*   Предназначен для работы с массивами примитивных и ссылочных типов.
*   Основные методы:
    *   `sort()` — сортировка массива целиком или его части.
    *   `binarySearch()` — бинарный поиск в отсортированном массиве.
    *   `equals()` — сравнение содержимого двух массивов (поэлементное сравнение).
    *   `deepEquals()` — сравнение многомерных массивов по содержимому.
    *   `toString()` и `deepToString()` — преобразование массива в строку для вывода.
    *   `copyOf()` и `copyOfRange()` — копирование массива или его части.
    *   `compare()` — сравнение двух массивов примитивных типов с возвратом порядка.
    *   `mismatch()` — поиск первого индекса, где массивы отличаются.
*   Методы упрощают выполнение часто повторяющихся операций с массивами[2][4][5][6].

## Класс Objects
*   Предоставляет утилитарные методы для работы с объектами.
*   Основные методы:
    *   `equals(Object a, Object b)` — безопасное сравнение объектов с учетом `null`.
    *   `hashCode(Object o)` — вычисление хеш-кода объекта с защитой от `null`.
    *   `requireNonNull(T obj)` — проверка на `null`, выбрасывает `NullPointerException`, если объект равен `null`.
    *   `toString(Object o)` — возвращает строковое представление объекта или `"null"`.
    *   `compare(T a, T b, Comparator<? super T> c)` — сравнение объектов с использованием компаратора.
*   Используется для безопасной и удобной работы с объектами, особенно при реализации методов `equals()`, `hashCode()` и `toString()`[6].

Таким образом, `Collections` и `Arrays` предоставляют мощные и удобные методы для работы с коллекциями и массивами, обеспечивая сортировку, поиск, сравнение, копирование и другие операции, а `Objects` помогает безопасно управлять объектами и их сравнениями в Java[1][2][3][6].


**Вопрос 13**

В Java потоки ввода-вывода делятся на два основных типа: байтовые и символьные.

## Байтовые потоки
* Работают с данными в виде байтов (8 бит).
* Основные базовые абстрактные классы:
  * `InputStream` — для чтения байтов.
  * `OutputStream` — для записи байтов.
* Популярные потомки:
  * `FileInputStream` и `FileOutputStream` — для работы с файлами.
  * `ByteArrayInputStream` и `ByteArrayOutputStream` — для работы с массивами байтов в памяти.
  * `BufferedInputStream` и `BufferedOutputStream` — для буферизации байтового ввода-вывода.
* Методы:
  * `read()` — чтение байта или массива байтов.
  * `write()` — запись байта или массива байтов.
  * `close()` — закрытие потока.
* Байтовые потоки удобны для работы с бинарными данными (например, изображениями, аудио).

## Символьные потоки
* Работают с символами Unicode (16 бит).
* Основные базовые абстрактные классы:
  * `Reader` — для чтения символов.
  * `Writer` — для записи символов.
* Популярные потомки:
  * `FileReader` и `FileWriter` — для работы с файлами символов.
  * `BufferedReader` и `BufferedWriter` — для буферизации символьного ввода-вывода.
  * `CharArrayReader` и `CharArrayWriter` — для работы с массивами символов.
  * `PrintWriter` — для удобного вывода с методами `print()` и `println()`.
* Методы:
  * `read()` — чтение символа или массива символов.
  * `write()` — запись символа или массива символов.
  * `close()` — закрытие потока.
* Символьные потоки удобны для работы с текстовыми данными с учетом кодировок.

## Мосты между байтовыми и символьными потоками
* `InputStreamReader` — преобразует байтовый поток `InputStream` в символьный `Reader`, учитывая кодировку.
* `OutputStreamWriter` — преобразует символьный поток `Writer` в байтовый `OutputStream`.
* Позволяют работать с текстом в нужной кодировке (например, UTF-8, Cp1251).

## Итог
| Тип потока       | Базовый класс     | Основные потомки                   | Назначение                      |
|------------------|-------------------|----------------------------------|--------------------------------|
| Байтовый поток   | InputStream / OutputStream | FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream | Работа с бинарными данными      |
| Символьный поток | Reader / Writer   | FileReader, FileWriter, BufferedReader, BufferedWriter, PrintWriter | Работа с текстовыми данными (Unicode) |

Таким образом, байтовые потоки оперируют с сырыми байтами, а символьные — с символами Unicode, обеспечивая удобство работы с текстом и кодировками. Для преобразования между ними используются классы-мосты `InputStreamReader` и `OutputStreamWriter`[1][2][3][5][6][7][8].


**Вопрос 14**

В Java потоки-фильтры — это специальные классы, которые принимают в конструкторе другой поток и оборачивают его, добавляя дополнительную функциональность, например, буферизацию, преобразование или форматирование данных[2][6].

## Потоки-фильтры

* Потоки-фильтры принимают в конструкторе исходный поток и преобразуют или дополняют его поведение.
* Они позволяют строить цепочки потоков, комбинируя разные операции ввода-вывода.
* Пример: буферизация, преобразование байтов в символы, форматированный вывод.

## Класс BufferedReader

* Является потомком `Reader` и представляет собой поток-фильтр для символьного ввода.
* Буферизует данные, считывая сразу большой блок символов из базового потока, что повышает производительность при последовательном чтении.
* Не преобразует байты в символы — для этого нужен `InputStreamReader`.
* Позволяет читать данные построчно с помощью метода `readLine()`.
* Обычно создаётся как обёртка над `InputStreamReader` или другим `Reader`, например:
  ```java
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  ```
* При закрытии `BufferedReader` автоматически закрывается и вложенный поток[3][7][8].

## Класс InputStreamReader

* Является мостом между байтовыми и символьными потоками.
* Наследуется от `Reader`.
* Преобразует байты из `InputStream` в символы с учётом заданной кодировки (по умолчанию — системная).
* Используется для чтения текстовых данных из байтовых источников, например, из консоли или файла.
* Пример использования:
  ```java
  InputStreamReader isr = new InputStreamReader(System.in, "UTF-8");
  ```
* Часто используется в связке с `BufferedReader` для эффективного и удобного чтения текста[2][7][8].

## Класс PrintStream

* Реализует байтовый поток вывода (`OutputStream`).
* Предназначен для вывода данных на консоль, в файл или другой байтовый источник.
* Поддерживает буферизацию и автоматический сброс буфера (например, при вызове `println()`).
* Позволяет выводить данные в текстовом формате с удобными методами `print()` и `println()`.
* В Java стандартный поток вывода `System.out` — это объект класса `PrintStream`.
* Может использоваться для вывода с заданной кодировкой через обёртки, например, `OutputStreamWriter`.
* Конструктор с параметром `autoFlush` позволяет автоматически сбрасывать буфер после вызова методов вывода строк[2][7].

---

Таким образом, `InputStreamReader` преобразует байты в символы, `BufferedReader` буферизует символы и предоставляет удобное чтение строк, а `PrintStream` обеспечивает удобный и буферизованный вывод байтов, часто используемый для вывода на консоль. Все они являются важными элементами цепочек потоков-фильтров в Java.


**Вопрос 15**

В Java стандартный ввод и вывод представлены тремя предопределёнными потоками в классе `System`:

- **`System.in`** — стандартный поток ввода, по умолчанию связанный с клавиатурой. Это объект типа `InputStream`, который читает байты с консоли. Для удобного чтения текстовых данных его обычно оборачивают в классы, например, `Scanner` или `BufferedReader` через `InputStreamReader`[1][2][4][6].

- **`System.out`** — стандартный поток вывода, по умолчанию связанный с консолью. Это объект класса `PrintStream`, который позволяет выводить данные в текстовом формате с помощью методов `print()`, `println()` и др. Можно перенаправлять вывод в файлы или другие потоки[2][4][5].

- **`System.err`** — стандартный поток вывода ошибок, также связанный с консолью. Используется для вывода сообщений об ошибках и предупреждениях. В отличие от `System.out`, поток `System.err` обычно не буферизуется, поэтому вывод ошибок отображается сразу[2][3].

---

### Класс Scanner

* Предназначен для удобного чтения данных из различных источников, включая стандартный ввод (`System.in`).
* Поддерживает чтение различных типов данных: строки (`nextLine()`), целые числа (`nextInt()`), числа с плавающей точкой, логические значения и др.
* Для работы со стандартным вводом создаётся так:
  ```java
  Scanner scanner = new Scanner(System.in);
  String line = scanner.nextLine();
  int number = scanner.nextInt();
  ```
* Позволяет удобно парсить входные данные по пробелам, переходам строк и другим разделителям[1][6].

---

Таким образом, для ввода с клавиатуры используется `System.in`, который часто оборачивают в `Scanner` для удобного чтения, а для вывода на консоль — `System.out` (обычно `PrintStream`), а для ошибок — `System.err`. Эти потоки являются стандартными и доступны через статические поля класса `System`.


**Вопрос 16**

В Java **сериализация объектов** — это процесс преобразования объекта в последовательность байтов для сохранения в файл, передачи по сети или кэширования, с возможностью последующего восстановления объекта (десериализации).

## Интерфейс Serializable

* `Serializable` — это **маркерный интерфейс**, который не содержит методов и служит для обозначения класса как сериализуемого[2][4].
* Чтобы объект можно было сериализовать, класс должен реализовать этот интерфейс.
* Все поля объекта также должны быть сериализуемыми (примитивные типы сериализуются по умолчанию).
* Если класс наследуется от несериализуемого суперкласса, у того должен быть конструктор без аргументов[2].
* Для сериализации используется класс `ObjectOutputStream`, для десериализации — `ObjectInputStream`[3][5].

## Модификатор transient

* Поля, объявленные с модификатором `transient`, **исключаются из процесса сериализации**[1][2][4].
* Это полезно для полей, которые не должны сохраняться, например, временные данные, ссылки на ресурсы, которые нельзя или не нужно сериализовать.
* При десериализации такие поля получают значение по умолчанию (например, `null` для объектов, `0` для чисел).
* При необходимости можно самостоятельно сериализовать и десериализовать `transient` поля, реализовав методы `writeObject(ObjectOutputStream out)` и `readObject(ObjectInputStream in)`[2][4].

---

### Пример использования Serializable и transient

```java
import java.io.Serializable;

public class Target implements Serializable {
    private int intField;
    private String strField;
    private transient int transientField; // не сериализуется

    public Target(int i, String s, int trn) {
        this.intField = i;
        this.strField = s;
        this.transientField = trn;
    }

    @Override
    public String toString() {
        return "Target{" +
               "intField=" + intField +
               ", strField='" + strField + '\'' +
               ", transientField=" + transientField +
               '}';
    }
}
```

При сериализации объекта `Target` поле `transientField` не будет сохранено, и после десериализации оно будет иметь значение по умолчанию (0)[2][4].

---

Таким образом, интерфейс `Serializable` позволяет отмечать классы для сериализации, а модификатор `transient` исключает отдельные поля из этого процесса, что даёт гибкость при сохранении состояния объектов.



**Вопрос 17**

В Java для работы с файлами используются несколько ключевых классов и интерфейсов, которые обеспечивают удобное и современное управление файловой системой.

## Интерфейс Path

* `Path` — это интерфейс из пакета `java.nio.file`, который является современным и более удобным аналогом класса `File`.
* Представляет путь к файлу или директории как последовательность элементов (папок и имени файла).
* Методы `Path` возвращают объекты типа `Path`, что упрощает работу с путями и исключает неоднозначность, свойственную классу `File` (где методы могли возвращать разные типы — строки, boolean или объекты `File`).
* Позволяет легко получать имя файла (`getFileName()`), родительский путь (`getParent()`), количество элементов пути (`getNameCount()`), подпути (`subpath()`), преобразовывать путь в строку (`toString()`) и др.
* Пример создания пути:
  ```java
  Path p1 = Paths.get("/foo/bar");
  Path p2 = Paths.get(URI.create("file:///foo/bar/Main.java"));
  ```

## Класс Paths

* Утилитный класс с статическими методами для создания объектов `Path`.
* Основные методы:
  * `Paths.get(String first, String... more)` — создает объект `Path` из одного или нескольких компонентов пути.
  * `Paths.get(URI uri)` — создает `Path` из URI.
* Используется для получения объекта `Path` для дальнейших операций.

## Класс File

* Более старый класс из пакета `java.io`, который работает с файлами и директориями.
* Позволяет получать информацию о файле (путь, права доступа, дата создания), создавать и удалять файлы и каталоги.
* Методы возвращают разные типы (например, `String`, `boolean`, `File`), что усложняет использование.
* Пример создания файла:
  ```java
  File file = new File("example.txt");
  ```
* Поддерживает навигацию по файловой системе, но менее удобен и функционален по сравнению с `Path` и `Files`.

## Класс Files

* Утилитный класс из пакета `java.nio.file`, содержащий множество статических методов для работы с файлами и директориями.
* Работает с объектами `Path`.
* Основные методы:
  * `createFile(Path path)` — создает новый файл.
  * `createDirectory(Path path)` — создает новую директорию.
  * `delete(Path path)` — удаляет файл или директорию.
  * `copy(Path source, Path target)` — копирует файл.
  * `move(Path source, Path target, CopyOption... options)` — перемещает или переименовывает файл.
  * `exists(Path path)` — проверяет существование файла или директории.
  * `isDirectory(Path path)` — проверяет, является ли путь директорией.
  * `size(Path path)` — возвращает размер файла.
* Обеспечивает более современный и удобный API для работы с файловой системой по сравнению с классом `File`.

---

### Итоговое сравнение

| Класс / Интерфейс | Назначение                              | Особенности и примеры использования                          |
|-------------------|---------------------------------------|-------------------------------------------------------------|
| `Path`            | Интерфейс для представления пути      | Современный способ работы с путями, возвращает объекты Path |
| `Paths`           | Утилитный класс для создания Path     | Статические методы `get()` для создания объектов Path       |
| `File`            | Класс для работы с файлами и каталогами | Старый класс, методы возвращают разные типы, менее удобен   |
| `Files`           | Утилитный класс с методами для файлов | Статические методы для создания, удаления, копирования и др.|

---

Таким образом, современный подход в Java — использовать интерфейс `Path` для представления путей, класс `Paths` для их создания и класс `Files` для выполнения операций с файлами и директориями, что обеспечивает более чистый и удобный API по сравнению с классом `File`[1][2][4][5][6][7].



**Вопрос 18**

Новый пакет ввода-вывода в Java называется NIO (New Input/Output) и предоставляет более эффективный и гибкий механизм работы с данными по сравнению с классическими потоками. Основными элементами этого пакета являются буферы и каналы.

## Буферы и каналы в Java NIO

- **Буферы (Buffers)** — это контейнеры для данных одного примитивного типа (чаще всего байтов). Они используются для временного хранения данных при операциях ввода-вывода. Буферы бывают двух типов: direct (прямой доступ к памяти, используемой устройством) и non-direct (память синхронизируется с памятью устройства)[8].

- **Каналы (Channels)** — это объекты, которые обеспечивают двунаправленный доступ к источнику или приемнику данных. Каналы могут читать и писать данные в буферы. Основные типы каналов в Java NIO:
  - FileChannel — для работы с файлами,
  - DatagramChannel — для передачи датаграмм,
  - SocketChannel — для сетевого ввода-вывода,
  - ServerSocketChannel — для установки сетевых соединений[8][9].

Каналы являются более эффективной альтернативой потокам, так как позволяют работать с данными напрямую через буферы и поддерживают операции позиционирования, блокировки и передачи данных между каналами.

## Класс FileChannel

`FileChannel` — это канал для чтения, записи, отображения и управления файлами. Он реализует интерфейс `SeekableByteChannel`, что позволяет перемещаться по файлу, читать и записывать данные в произвольных позициях[2][5].

### Основные возможности FileChannel:

- Чтение и запись данных в файл с возможностью указания позиции,
- Получение и установка текущей позиции в файле,
- Получение размера файла,
- Отображение части файла в память (memory-mapped files) через метод `map()`,
- Передача данных напрямую между каналами (например, для копирования файлов),
- Блокировка частей файла для синхронизации доступа из разных потоков,
- Принудительная запись данных на диск для предотвращения потери данных[5][6].

### Работа с FileChannel

Для открытия канала используется, например, класс `RandomAccessFile` или потоки `FileInputStream`/`FileOutputStream` с вызовом метода `getChannel()`:

```java
RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
FileChannel channel = file.getChannel();
```

Чтение данных осуществляется через буфер `ByteBuffer`:

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);
```

Позиция чтения/записи может быть получена и изменена:

```java
long position = channel.position();
channel.position(5);
```

Размер файла можно получить методом `size()`:

```java
long size = channel.size();
```

### Преимущества FileChannel

- Возможность позиционированного доступа к файлу,
- Эффективная работа с большими файлами через memory-mapped buffers,
- Высокая производительность при передаче данных между каналами,
- Поддержка блокировок для многопоточного доступа[5].

Таким образом, новый пакет ввода-вывода Java NIO с классом `FileChannel` и буферами предоставляет мощный и гибкий инструмент для эффективной работы с файлами и другими источниками данных, превосходящий по возможностям классические потоки ввода-вывода[1][5][6][8].

**Вопрос 19**

Взаимодействие Java с базами данных осуществляется через **JDBC (Java Database Connectivity)**, представляющий собой платформенно-независимый стандарт, позволяющий Java-приложениям взаимодействовать с различными СУБД[1][3][5][6]. JDBC API предоставляет набор интерфейсов и классов в пакете `java.sql`, позволяющих отправлять SQL-запросы в базу данных и обрабатывать результаты[1][5][6].

### Основные элементы JDBC:

1.  **JDBC API**: Предоставляет интерфейс между Java-приложением и JDBC-менеджером[3]. Содержит интерфейсы для разработчиков приложений и для разработчиков драйверов[1].

2.  **JDBC-драйверы**: Реализации JDBC API для конкретных баз данных, обеспечивающие связь между JDBC-менеджером и драйвером базы данных[3][6]. Драйверы позволяют получать соединение с базой данных по специально описанному URL[1][7][8]. Существуют различные типы драйверов JDBC[6][9]:
    *   **Тип 1 (JDBC-ODBC bridge)**: Использует ODBC драйвер, установленный в системе (устаревший)[6][9].
    *   **Тип 2 (Native API)**: Использует клиентские библиотеки базы данных (платформозависимый)[6][9].
    *   **Тип 3 (Net-protocol driver)**: Использует промежуточный сервер приложений для преобразования запросов[6][9].
    *   **Тип 4 (Thin driver)**: Непосредственно преобразует вызовы JDBC в протокол базы данных[6][9].

3.  **DriverManager**: Класс, управляющий JDBC-драйверами[3]. Он загружает драйверы и предоставляет соединение с базой данных[1][7][8].

4.  **Connection**: Интерфейс, представляющий соединение с базой данных[3]. Через объект `Connection` происходит взаимодействие с СУБД[3].

5.  **Statement**: Интерфейс, используемый для выполнения SQL-запросов[3][5]. Существуют различные типы `Statement`, такие как `PreparedStatement` (для параметризованных запросов) и `CallableStatement` (для вызова хранимых процедур)[3][5].

6.  **ResultSet**: Интерфейс, представляющий результирующий набор данных, полученный из базы данных после выполнения запроса[3].

### Процесс взаимодействия с базой данных через JDBC:

1.  **Загрузка драйвера**: Драйвер загружается в память[7][8].
2.  **Установка соединения**: Устанавливается соединение с базой данных с использованием URL, имени пользователя и пароля[3][7][8].
3.  **Создание Statement**: Создается объект `Statement` для выполнения SQL-запросов[3][8].
4.  **Выполнение запроса**: SQL-запрос выполняется с помощью методов `executeQuery()` (для запросов `SELECT`) или `executeUpdate()` (для запросов `INSERT`, `UPDATE`, `DELETE`)[5].
5.  **Обработка результатов**: Результаты запроса обрабатываются через объект `ResultSet`[5].
6.  **Закрытие соединения**: Все соединения закрываются[3][8].

JDBC обеспечивает независимость от конкретной СУБД, позволяя Java-приложениям взаимодействовать с различными базами данных при наличии соответствующего драйвера[5]. The user is interested in Java and object-oriented programming [10][11]. They are also learning about Java's collections and input/output streams, which are relevant to working with databases [12][13].

**Вопрос 20**

## Создание соединения с базой данных в Java через JDBC

### Класс DriverManager

`DriverManager` — это класс-утилита, управляющий списком зарегистрированных JDBC-драйверов и устанавливающий соединения с базой данных. Он выбирает подходящий драйвер по URL-адресу подключения и предоставляет объект интерфейса `Connection`.

Основной метод для создания соединения:

```java
Connection connection = DriverManager.getConnection(String url, String user, String password);
```

- `url` — строка подключения в формате `jdbc:subprotocol:subname`, например, для MySQL:  
  `"jdbc:mysql://localhost/название_базы"`
- `user` и `password` — логин и пароль для доступа к базе.

Перед созданием соединения рекомендуется загрузить драйвер:

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

Это регистрирует драйвер в `DriverManager` (в новых версиях Java часто не требуется явно).

---

### Интерфейс Connection

`Connection` — интерфейс, представляющий активное соединение с базой данных. Через объект `Connection` выполняются SQL-запросы, создаются объекты `Statement`, управляются транзакции и закрывается соединение.

Основные методы `Connection`:

- `createStatement()` — создание объекта для выполнения SQL-запросов,
- `prepareStatement(String sql)` — создание подготовленного запроса с параметрами,
- `commit()` и `rollback()` — управление транзакциями,
- `close()` — закрытие соединения и освобождение ресурсов,
- `setAutoCommit(boolean autoCommit)` — включение/отключение автокоммита.

---

### Пример создания соединения и создания базы данных

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class CreateDBJdbc {
    static final String DATABASE_URL = "jdbc:mysql://localhost/";
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String USER = "ваш_пользователь";
    static final String PASSWORD = "ваш_пароль";

    public static void main(String[] args) {
        Connection connection = null;
        Statement statement = null;

        try {
            // Регистрация драйвера
            Class.forName(JDBC_DRIVER);
            System.out.println("Connecting to DB...");
            // Создание соединения
            connection = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            // Создание объекта Statement для выполнения SQL
            statement = connection.createStatement();
            String sql = "CREATE DATABASE PROSELYTE_JDBC_DB";
            statement.executeUpdate(sql);
            System.out.println("Database successfully created...");
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            // Закрытие ресурсов
            try {
                if (statement != null) statement.close();
                if (connection != null) connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

### Ключевые моменты

- `DriverManager` управляет драйверами и создаёт соединение с базой данных.
- Метод `getConnection()` возвращает объект `Connection`.
- `Connection` — основной интерфейс для взаимодействия с базой: выполнение запросов, управление транзакциями, закрытие соединения.
- Для подключения требуется корректно сформированный URL, имя пользователя и пароль.
- После работы соединение обязательно закрывается для освобождения ресурсов.

---

Таким образом, создание соединения с базой данных в Java через JDBC сводится к загрузке драйвера, вызову `DriverManager.getConnection()` и работе с полученным объектом `Connection` для выполнения SQL-запросов и управления транзакциями[1][2][5][6].

**Вопрос 21**

## Создание запросов в JDBC: интерфейсы Statement, PreparedStatement и CallableStatement

### 1. Интерфейс **Statement**

- Используется для выполнения простых SQL-запросов без параметров.
- Подходит для одноразового выполнения SQL, например, DDL-команд (`CREATE`, `DROP`).
- Методы:
  - `execute(String sql)` — выполнение любого SQL-запроса,
  - `executeQuery(String sql)` — выполнение запроса `SELECT`, возвращает `ResultSet`,
  - `executeUpdate(String sql)` — выполнение запросов `INSERT`, `UPDATE`, `DELETE`, возвращает количество изменённых строк,
  - `executeBatch()` — выполнение пакета запросов.
- Не поддерживает параметризацию, что повышает риск SQL-инъекций при динамическом формировании запросов.

### 2. Интерфейс **PreparedStatement**

- Наследует `Statement`.
- Представляет предкомпилированный SQL-запрос, который может содержать параметры-заполнители `?`.
- Позволяет многократно выполнять один и тот же запрос с разными параметрами, что повышает производительность.
- Параметры задаются через методы `setInt()`, `setString()`, `setDate()` и др.
- Обеспечивает защиту от SQL-инъекций, так как параметры экранируются драйвером.
- Создаётся через `Connection.prepareStatement(sql)`.
- Пример:

```java
String sql = "UPDATE employees SET salary = ? WHERE id = ?";
PreparedStatement pstmt = connection.prepareStatement(sql);
pstmt.setDouble(1, 5000.0);
pstmt.setInt(2, 101);
pstmt.executeUpdate();
```

### 3. Интерфейс **CallableStatement**

- Наследует `PreparedStatement`.
- Предназначен для вызова хранимых процедур в базе данных.
- Позволяет работать с тремя типами параметров:
  - `IN` — входные,
  - `OUT` — выходные,
  - `INOUT` — входные/выходные.
- Позволяет регистрировать выходные параметры и получать их значения после выполнения процедуры.
- Создаётся через `Connection.prepareCall(sql)`, где `sql` — вызов процедуры с параметрами-заполнителями.
- Пример вызова хранимой процедуры:

```java
CallableStatement cstmt = connection.prepareCall("{CALL ADD(?, ?, ?)}");
cstmt.setInt(1, 123); // IN параметр
cstmt.setInt(2, 234); // IN параметр
cstmt.registerOutParameter(3, Types.INTEGER); // OUT параметр
cstmt.execute();
int sum = cstmt.getInt(3); // получение результата
```

---

### Иерархия и особенности

| Интерфейс          | Назначение                         | Параметры           | Особенности                                  |
|--------------------|----------------------------------|---------------------|----------------------------------------------|
| Statement          | Выполнение простых SQL-запросов  | Нет                 | Не поддерживает параметры, простой в использовании |
| PreparedStatement  | Предкомпилированные запросы с параметрами | Только входные (IN)  | Повышенная производительность, защита от SQL-инъекций |
| CallableStatement  | Вызов хранимых процедур          | IN, OUT, INOUT      | Поддержка выходных параметров, сложные процедуры |

---

### Итоги

- Для простых одноразовых запросов подходит `Statement`.
- Для многократного выполнения параметризованных запросов — `PreparedStatement`.
- Для вызова хранимых процедур с возможностью работы с выходными параметрами — `CallableStatement`.

Все три интерфейса создаются через методы объекта `Connection`:

```java
Statement stmt = connection.createStatement();
PreparedStatement pstmt = connection.prepareStatement(sql);
CallableStatement cstmt = connection.prepareCall(sql);
```

Это позволяет гибко и эффективно работать с базой данных в зависимости от задач[1][2][3][4][5][6][8].

**Вопрос 22**

## Выполнение запросов в JDBC: методы execute, executeQuery и executeUpdate

Для выполнения SQL-запросов через объект `Statement` в JDBC используются три основных метода, которые различаются по типу выполняемых команд и возвращаемым результатам.

---

### 1. Метод **executeQuery(String sql)**

- Предназначен для выполнения SQL-запросов типа `SELECT`, которые возвращают данные.
- Возвращает объект `ResultSet`, содержащий результат выборки.
- Пример использования:

```java
ResultSet rs = statement.executeQuery("SELECT * FROM employees");
while (rs.next()) {
    String name = rs.getString("name");
    int salary = rs.getInt("salary");
    // обработка данных
}
```

---

### 2. Метод **executeUpdate(String sql)**

- Используется для выполнения SQL-команд, изменяющих данные или структуру базы:
  - `INSERT`, `UPDATE`, `DELETE`,
  - DDL-команды: `CREATE TABLE`, `DROP TABLE` и др.
- Возвращает `int` — количество строк, затронутых операцией, или 0, если команда не изменяет строки (например, создание таблицы).
- Пример:

```java
int rowsAffected = statement.executeUpdate("UPDATE employees SET salary = salary + 1000");
System.out.println("Обновлено строк: " + rowsAffected);
```

---

### 3. Метод **execute(String sql)**

- Универсальный метод для выполнения любых SQL-команд.
- Возвращает `boolean`:
  - `true` — если результатом является набор строк (например, `SELECT`),
  - `false` — если команда не возвращает набор строк (например, `INSERT`, `UPDATE`).
- После вызова метода для получения результата используют:
  - `getResultSet()` — для получения `ResultSet` при `true`,
  - `getUpdateCount()` — для получения количества затронутых строк при `false`.
- Пример:

```java
boolean hasResultSet = statement.execute("SELECT * FROM employees");
if (hasResultSet) {
    ResultSet rs = statement.getResultSet();
    // обработка данных
} else {
    int updateCount = statement.getUpdateCount();
    System.out.println("Изменено строк: " + updateCount);
}
```

---

### Итоговое сравнение

| Метод           | Для каких запросов           | Возвращаемое значение       | Особенности                              |
|-----------------|-----------------------------|-----------------------------|-----------------------------------------|
| `executeQuery`  | Только SELECT               | `ResultSet`                 | Удобен для выборки данных                |
| `executeUpdate` | INSERT, UPDATE, DELETE, DDL | `int` (число изменённых строк) | Для изменения данных и структуры БД     |
| `execute`       | Любые SQL-команды           | `boolean`                   | Универсальный, требует дополнительной обработки результата |

---

Таким образом, выбор метода зависит от типа SQL-запроса: для выборки данных — `executeQuery`, для обновления — `executeUpdate`, а если тип запроса заранее неизвестен — универсальный `execute`[1][2][3][5].

**Вопрос 23**

## Обработка результатов запроса в JDBC: интерфейс ResultSet и получение значений

### Интерфейс ResultSet

`ResultSet` представляет собой таблицу данных, полученную в результате выполнения SQL-запроса (обычно `SELECT`). Он обеспечивает построчный доступ к этим данным и позволяет перемещаться по строкам результата.

- **Курсор** — внутренний указатель, который указывает на текущую строку в наборе результатов. Изначально курсор находится «до первой строки» (позиция перед первой записью).
- Для перехода к следующей строке используется метод `next()`, который возвращает `true`, если следующая строка существует, и `false` при достижении конца набора.

### Основные методы перемещения по ResultSet

- `boolean next()` — перейти к следующей строке,
- `boolean previous()` — перейти к предыдущей (если ResultSet скроллируемый),
- `boolean isBeforeFirst()`, `isAfterLast()`, `isFirst()`, `isLast()` — проверить позицию курсора,
- `int getRow()` — получить номер текущей строки (начинается с 1).

### Получение значений из ResultSet

Для извлечения данных из текущей строки используются методы `getXXX()`, где `XXX` — тип данных:

- `getString(columnIndex или columnName)` — получить строку,
- `getInt(columnIndex или columnName)` — получить целое число,
- `getDouble()`, `getDate()`, `getBoolean()` и др. — для других типов.

Индексация колонок начинается с 1. Можно обращаться как по индексу, так и по имени столбца.

Пример:

```java
while (rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    double salary = rs.getDouble("salary");
    System.out.printf("ID: %d, Name: %s, Salary: %.2f%n", id, name, salary);
}
```

### Обработка NULL-значений

Если в базе поле может быть `NULL`, после вызова `getXXX()` рекомендуется проверить методом `wasNull()`, чтобы отличить `NULL` от значений по умолчанию (например, 0 для чисел):

```java
int value = rs.getInt("some_column");
if (rs.wasNull()) {
    // обработка NULL
}
```

### Пример полного использования ResultSet

```java
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT id, name, salary FROM employees");

while (rs.next()) {
    int id = rs.getInt(1); // или rs.getInt("id")
    String name = rs.getString("name");
    double salary = rs.getDouble("salary");
    System.out.println(id + " | " + name + " | " + salary);
}

rs.close();
stmt.close();
```

---

### Итоги

- `ResultSet` — это результат выполнения запроса, предоставляющий построчный доступ к данным.
- Для перемещения по строкам используется метод `next()`.
- Для получения значений из столбцов — методы `getInt()`, `getString()`, `getDouble()` и др.
- Можно обращаться к столбцам по имени или индексу.
- Для проверки наличия `NULL` используется метод `wasNull()`.

Такой подход позволяет эффективно и удобно обрабатывать результаты запросов в JDBC[1][2][3][4][5].

**Вопрос 24**

## Многопоточность в Java: класс Thread, интерфейс Runnable и состояния потока

### Класс Thread

- Представляет поток исполнения — отдельный легковесный процесс внутри программы.
- Для создания потока можно унаследовать класс `Thread` и переопределить метод `run()`, в котором описывается код, выполняемый в отдельном потоке.
- Запуск потока осуществляется вызовом метода `start()`, который создаёт новый поток и вызывает `run()` асинхронно.
- Пример:

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Поток запущен");
    }
}

MyThread t = new MyThread();
t.start();
```

### Интерфейс Runnable

- Определяет единственный метод `run()`.
- Позволяет реализовать задачу, которую можно выполнить в отдельном потоке.
- Для запуска создаётся объект `Thread`, которому в конструктор передаётся реализация `Runnable`.
- Такой подход более гибкий, так как класс может наследовать другой класс и одновременно реализовывать `Runnable`.
- Пример:

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Поток через Runnable");
    }
}

Thread t = new Thread(new MyRunnable());
t.start();
```

### Состояния потока в Java

Основные состояния потока (по спецификации JVM):

- **NEW** — поток создан, но метод `start()` ещё не вызван.
- **RUNNABLE** — поток готов к выполнению или выполняется. После вызова `start()` поток переходит в это состояние, но фактическое выполнение зависит от планировщика ОС[1].
- **BLOCKED** — поток заблокирован, ожидает монитор (например, при входе в synchronized-блок).
- **WAITING** — поток ожидает уведомления без ограничения по времени (методы `wait()`, `join()` без таймаута).
- **TIMED_WAITING** — поток ожидает с ограничением по времени (например, `sleep()`, `join(timeout)`).
- **TERMINATED (DEAD)** — поток завершил выполнение метода `run()` и больше не активен.

### Ключевые моменты

- Для запуска нового потока всегда вызывается `start()`, а не `run()` напрямую. Вызов `run()` не создаёт новый поток, а выполняется в текущем.
- Планировщик потоков JVM и ОС решают, когда и какой поток выполняется.
- Поток после завершения нельзя запустить повторно.
- Использование `Runnable` предпочтительнее, если класс уже наследует другой класс, или для разделения задачи и управления потоком[2][4][6][8].

---

Таким образом, многопоточность в Java реализуется через класс `Thread` и интерфейс `Runnable`. Поток создаётся, запускается и переходит через несколько состояний от создания до завершения, что позволяет выполнять несколько задач параллельно.

**Вопрос 25**

## Гонки, синхронизация потоков, мониторы и модификатор synchronized в Java

### Гонки (Race Conditions)

Состояние гонки возникает, когда несколько потоков одновременно пытаются получить доступ к общим данным или ресурсам, при этом как минимум один поток пытается изменить эти данные[1][2][3][5]. Результат выполнения программы зависит от непредсказуемого порядка выполнения потоков[4][5]. Это может привести к непредсказуемым ошибкам, которые сложно воспроизвести и отладить[5][8].

Пример гонки: два потока одновременно увеличивают значение одной и той же переменной.  Каждый поток выполняет три операции: чтение значения из памяти, увеличение значения и запись обратно в память. Если потоки выполняют эти операции попеременно, конечное значение переменной может быть неверным[5].

### Синхронизация потоков

Синхронизация потоков — это механизм, обеспечивающий упорядоченный доступ к общим ресурсам, предотвращая состояния гонки[2][5].  В Java для синхронизации используются мониторы и ключевое слово `synchronized`.

### Мониторы

Каждый объект в Java имеет связанный с ним монитор, который можно использовать для управления доступом к synchronized-блокам и методам.  Монитор позволяет только одному потоку в каждый момент времени выполнять код, защищённый этим монитором.

### Модификатор `synchronized`

Модификатор `synchronized` используется для синхронизации доступа к блокам кода или методам. Он гарантирует, что только один поток может выполнять synchronized-код для данного объекта в один момент времени.

1.  **synchronized-метод**:

    ```java
    public synchronized void increment() {
        count++;
    }
    ```

    Когда поток вызывает `increment()`, он должен получить блокировку монитора объекта, на котором вызывается метод.  Другие потоки, пытающиеся вызвать этот или любой другой `synchronized` метод этого же объекта, будут заблокированы до тех пор, пока первый поток не освободит монитор.
2.  **synchronized-блок**:

    ```java
    public void someMethod() {
        synchronized (this) {
            // Критическая секция
            // Код, требующий синхронизации
        }
    }
    ```

    В этом случае, поток должен получить блокировку монитора объекта `this`, прежде чем выполнить код внутри `synchronized` блока.
    Можно синхронизироваться по любому объекту, например:

    ```java
    private Object lock = new Object();
    public void someMethod() {
        synchronized (lock) {
            // Критическая секция
        }
    }
    ```
    Это позволяет более точно контролировать область синхронизации.

### Предотвращение гонок

Для предотвращения состояний гонки необходимо правильно спроектировать многопоточную систему и использовать механизмы синхронизации[6]. Важно определить критические секции кода, где происходит доступ к общим ресурсам, и защитить их с помощью `synchronized` или других средств синхронизации.

Дополнительные способы предотвращения гонок:

*   Использование неизменяемых объектов (immutable objects): Если объекты не могут быть изменены после создания, то не требуется синхронизация доступа к ним.
*   Использование потокобезопасных коллекций: Классы из пакета `java.util.concurrent` (например, `ConcurrentHashMap`, `CopyOnWriteArrayList`) обеспечивают потокобезопасный доступ к коллекциям.
*   Минимизация области синхронизации: Чем меньше код, выполняемый под блокировкой, тем меньше вероятность возникновения проблем с производительностью.
*   Использование `volatile` для переменных:  Ключевое слово `volatile` гарантирует, что изменения переменной будут видны всем потокам немедленно.

### Пример

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Count: " + counter.getCount()); // Ожидаем 2000
    }
}
```

В этом примере класс `Counter` использует `synchronized` метод `increment()` для предотвращения состояний гонки при увеличении переменной `count`.  Без `synchronized` результат мог бы быть меньше 2000 из-за одновременного доступа к переменной из разных потоков.

Ранее вы интересовались Java и объектно-ориентированным программированием, а также изучали потоки ввода-вывода [9], коллекции [10] и подключение к базам данных [11][12][13]. Многопоточность тесно связана с этими темами, поскольку позволяет эффективно использовать ресурсы и создавать более производительные приложения. [9][10][11][12][13]

**Вопрос 26**

Многопоточность в Java — это механизм, позволяющий выполнять несколько потоков (задач) одновременно, что повышает эффективность и отзывчивость программ. Для управления многопоточными задачами в Java широко используются интерфейсы Executor, ExecutorService, Callable и Future. Рассмотрим их подробнее.

## Интерфейс Executor

Интерфейс `Executor` предоставляет способ отделить отправку задачи от механизма её выполнения, включая детали использования потоков и планирования[1]. Вместо создания и запуска потоков вручную (`new Thread(runnable).start()`), задачи можно передавать исполнителю:

```java
Executor executor = ...;
executor.execute(new RunnableTask());
```

`Executor` не обязательно выполняет задачи асинхронно — в простейшем случае задача может быть выполнена в вызывающем потоке. Однако чаще задачи выполняются в отдельных потоках.

## Интерфейс ExecutorService

`ExecutorService` расширяет `Executor` и добавляет методы для управления жизненным циклом исполнителя и получения результатов выполнения задач через объекты `Future`[2]. Основные возможности:

- Управление завершением: методы `shutdown()` (позволяет завершить ранее отправленные задачи) и `shutdownNow()` (пытается прервать текущие задачи).
- Методы `submit()` для отправки задач, которые возвращают `Future` — объект для отслеживания и получения результата.
- Методы `invokeAll()` и `invokeAny()` для пакетного выполнения коллекций задач.
- Метод `awaitTermination()` для ожидания завершения всех задач после вызова `shutdown()`.

Пример использования:

```java
ExecutorService executor = Executors.newFixedThreadPool(5);
Future<String> future = executor.submit(new CallableTask());
String result = future.get(); // блокирует до получения результата
executor.shutdown();
```

## Интерфейс Callable

`Callable<V>` — это функциональный интерфейс, представляющий задачу, которая возвращает результат типа `V` и может выбрасывать исключения[3]. В отличие от `Runnable`, метод `call()` возвращает значение и может бросать проверяемые исключения.

Определение интерфейса:

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

Пример реализации:

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "Result at " + System.currentTimeMillis();
    }
}
```

`Callable` хорошо подходит для задач, результат которых нужно получить после выполнения, например, для операций ввода-вывода или вычислений.

## Интерфейс Future

`Future<V>` представляет результат асинхронной операции, который будет доступен в будущем[4]. Позволяет:

- Проверить завершена ли задача (`isDone()`).
- Отменить задачу (`cancel()`).
- Получить результат (`get()`), который блокирует вызывающий поток до завершения задачи.
- Получить результат с таймаутом (`get(timeout, unit)`).

Интерфейс:

```java
public interface Future<V> {
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
}
```

## Итог

| Интерфейс       | Назначение                                                                                  |
|-----------------|--------------------------------------------------------------------------------------------|
| `Executor`      | Отделяет отправку задачи от её выполнения, упрощает запуск потоков                          |
| `ExecutorService` | Расширяет `Executor`, управляет жизненным циклом, возвращает `Future` для отслеживания     |
| `Callable`      | Представляет задачу с возвращаемым результатом и возможностью выбрасывать исключения       |
| `Future`        | Представляет результат асинхронной задачи, позволяет получить результат, отменить задачу   |

Использование этих интерфейсов позволяет писать эффективный, масштабируемый и управляемый многопоточный код в Java[1][2][3][4][5].

**Вопрос 27**

Класс `Executors` и интерфейс `ExecutorService` в Java тесно связаны с управлением многопоточностью через пулы потоков.

## Класс Executors

`Executors` — это утилитный класс-фабрика, который предоставляет статические методы для создания различных реализаций интерфейса `ExecutorService`. Он упрощает создание и настройку пулов потоков, скрывая сложность непосредственного создания объектов типа `ThreadPoolExecutor` или `ScheduledThreadPoolExecutor`.

Основные фабричные методы класса `Executors`:

- `newFixedThreadPool(int n)`: создает пул с фиксированным числом потоков. Задачи выполняются в этих потоках, если все заняты — новые задачи ждут в очереди.
- `newCachedThreadPool()`: создает эластичный пул, где потоки создаются по мере необходимости и переиспользуются, если свободны.
- `newSingleThreadExecutor()`: создает пул из одного потока, задачи выполняются последовательно.
- `newScheduledThreadPool(int n)`: создает пул потоков с возможностью планирования задач с задержкой или периодическим выполнением.

Пример создания фиксированного пула:

```java
ExecutorService executor = Executors.newFixedThreadPool(10);
```

## Интерфейс ExecutorService

`ExecutorService` расширяет базовый интерфейс `Executor` и предоставляет расширенные возможности для управления пулом потоков и выполнения задач:

- Позволяет запускать задачи типа `Runnable` и `Callable`.
- Методы `submit()` возвращают объект `Future`, с помощью которого можно получить результат или статус задачи.
- Методы `invokeAll()` и `invokeAny()` позволяют запускать набор задач и получать результаты.
- Управление жизненным циклом пула: методы `shutdown()` и `shutdownNow()` для корректного завершения работы.
- Возможность планирования задач с задержкой через наследуемый интерфейс `ScheduledExecutorService`.

## Пулы потоков

Пул потоков — это набор заранее созданных потоков, которые переиспользуются для выполнения множества задач. Это снижает накладные расходы на создание и уничтожение потоков, улучшает производительность и управление ресурсами.

Типы пулов, создаваемых через `Executors`:

| Тип пула               | Описание                                                                                   |
|-----------------------|--------------------------------------------------------------------------------------------|
| FixedThreadPool       | Фиксированное число потоков, задачи ставятся в очередь, если все потоки заняты              |
| CachedThreadPool      | Эластичный пул, создающий новые потоки при необходимости и переиспользующий свободные       |
| SingleThreadExecutor  | Один поток, задачи выполняются последовательно                                             |
| ScheduledThreadPool   | Пул потоков с поддержкой планирования задач с задержкой или периодическим выполнением      |

## Пример использования

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Runnable task = () -> {
    System.out.println("Task executed by " + Thread.currentThread().getName());
};

executor.submit(task);
executor.shutdown();
```

В этом примере создается пул из двух потоков, в который отправляется задача на выполнение. После выполнения задач пул корректно завершается.

---

Таким образом, класс `Executors` предоставляет удобные фабричные методы для создания различных видов пулов потоков, а интерфейс `ExecutorService` управляет выполнением задач и жизненным циклом этих пулов, обеспечивая эффективную многопоточность в Java[1][2][3][5][6][7].

**Вопрос 28**

Модель памяти в Java (Java Memory Model, JMM) описывает правила взаимодействия потоков через общую память и гарантирует корректность и предсказуемость многопоточного исполнения программ[3][6].

## Модель памяти и кэширование

В JVM память делится на кучу (heap) и стеки потоков (thread stacks). Каждый поток имеет собственный стек вызовов, а объекты хранятся в общей куче[1]. При многопоточном выполнении каждый поток может иметь локальный кэш процессора, где хранятся копии переменных из общей памяти. Это приводит к тому, что изменения одной переменной в одном потоке могут быть не сразу видны другим потокам, если они читают устаревшие значения из кэша[5].

Из-за оптимизаций компилятора и процессора порядок выполнения операций может отличаться от порядка, написанного в коде (reordering), что усложняет правильное взаимодействие потоков[2][5].

## Модификатор volatile

Ключевое слово `volatile` в Java используется для переменных, к которым обращаются несколько потоков. Оно гарантирует:

- Чтение и запись `volatile` переменной происходит напрямую из основной памяти, минуя локальные кэши процессора.
- Операции с `volatile` переменной создают так называемые "memory barriers", запрещающие переупорядочивание операций вокруг них.
- Изменения `volatile` переменной, сделанные одним потоком, будут гарантированно видны другим потокам.

Таким образом, `volatile` обеспечивает видимость изменений между потоками и частично упрощает синхронизацию[3][5][6].

## Условие "happens-before"

Отношение **happens-before** — это фундаментальное правило в JMM, которое определяет порядок видимости операций между потоками. Если операция A *happens-before* операции B, то все изменения, сделанные до A, гарантированно будут видны операции B.

Основные правила happens-before включают:

- Внутрипоточный порядок: операции в одном потоке выполняются в порядке, определённом программой.
- Запуск потока: действия до вызова `Thread.start()` *happens-before* всем действиям в новом потоке.
- Завершение потока: все действия в потоке *happens-before* возвращению из `Thread.join()`.
- Взаимодействие с `volatile`: запись в `volatile` переменную *happens-before* последующему чтению этой переменной.
- Синхронизированные блоки: выход из синхронизированного блока *happens-before* входу в следующий синхронизированный блок по тому же монитору[3][5][6].

Это отношение гарантирует корректную видимость и упорядоченность операций в многопоточной среде, предотвращая проблемы с кэшированием и переупорядочиванием.

---

Таким образом, модель памяти Java регулирует, как и когда изменения памяти становятся видимыми между потоками, а `volatile` и happens-before обеспечивают механизмы для безопасного и предсказуемого взаимодействия потоков в условиях многопоточности.

**Вопрос 29**

Взаимодействие потоков в Java часто требует координации, когда один поток должен ожидать определенного события или состояния, а другой — уведомить об этом. Для таких целей используются методы `wait()`, `notify()` и `notifyAll()`, определённые в классе `Object`.

## Основные методы взаимодействия потоков

- **`wait()`**  
  Вызывается из синхронизированного блока или метода и заставляет текущий поток:
  - Освободить монитор (блокировку) объекта, на котором вызван метод.
  - Перейти в состояние ожидания до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` на том же объекте.  
  Поток при этом приостанавливается и не занимает процессорное время[1][3][4].

- **`notify()`**  
  Пробуждает один из потоков, ожидающих на мониторе данного объекта (то есть вызвавших `wait()`). Какой именно поток будет разбужен — не определено и зависит от планировщика потоков. Метод тоже вызывается из синхронизированного контекста[1][3][4].

- **`notifyAll()`**  
  Пробуждает все потоки, ожидающие на мониторе объекта. Все они переходят из состояния ожидания в состояние готовности, но только один из них сможет получить монитор и продолжить выполнение[1][3][4].

## Важные условия использования

- Все три метода должны вызываться только внутри синхронизированного блока или метода, иначе будет выброшено исключение `IllegalMonitorStateException`[1][2][3][4].
- Поток, вызвавший `wait()`, освобождает монитор, позволяя другим потокам войти в синхронизированный блок.
- После пробуждения потока с помощью `notify()` или `notifyAll()`, поток не сразу продолжает выполнение — он должен заново получить монитор объекта.

## Пример классической задачи "Производитель-Потребитель"

```java
public class Buffer {
    private int contents;
    private boolean available = false;

    public synchronized void put(int value) {
        while (available) {
            try {
                wait(); // ждем, пока буфер освободится
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        contents = value;
        available = true;
        notifyAll(); // уведомляем потребителей
    }

    public synchronized int get() {
        while (!available) {
            try {
                wait(); // ждем, пока появятся данные
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        available = false;
        notifyAll(); // уведомляем производителей
        return contents;
    }
}
```

В этом примере поток-производитель вызывает `put()`, если буфер занят — он ждет (`wait()`), а после помещения данных вызывает `notifyAll()`, чтобы разбудить потребителя. Потребитель, вызывая `get()`, ждет, пока данные появятся, и после чтения уведомляет производителя.

---

Таким образом, методы `wait()`, `notify()` и `notifyAll()` обеспечивают эффективное взаимодействие и синхронизацию потоков, позволяя одному потоку приостанавливать выполнение до наступления нужного события, а другому — уведомлять об этом событии[1][3][4][5][7].

**Вопрос 30**

## Интерфейс Lock

`Lock` — это интерфейс из пакета `java.util.concurrent.locks`, который предоставляет более гибкий механизм блокировок по сравнению с ключевым словом `synchronized`. Основные методы:

- `void lock()` — захватывает блокировку, ожидая её освобождения, если она занята.
- `void unlock()` — освобождает блокировку.
- `boolean tryLock()` — пытается захватить блокировку без ожидания, возвращает `true`, если удалось.
- `Condition newCondition()` — создает объект `Condition` для организации ожидания и уведомления потоков.

Класс `ReentrantLock` — одна из наиболее распространённых реализаций `Lock`. Он поддерживает повторный захват блокировки одним потоком (reentrant), тайм-ауты ожидания и прерывания.

Пример использования `ReentrantLock`:

```java
Lock lock = new ReentrantLock();

lock.lock();
try {
    // критическая секция
} finally {
    lock.unlock();
}
```

## Интерфейс ReadWriteLock

`ReadWriteLock` — интерфейс, который определяет блокировку с разделением на чтение и запись:

- Позволяет нескольким потокам одновременно захватывать блокировку на чтение (shared lock), если нет потоков, захвативших блокировку на запись.
- Запись (exclusive lock) допускается только одному потоку и блокирует всех читателей.

Основные методы:

- `Lock readLock()` — возвращает блокировку для чтения.
- `Lock writeLock()` — возвращает блокировку для записи.

Класс `ReentrantReadWriteLock` — стандартная реализация `ReadWriteLock`, поддерживающая повторный захват.

Пример:

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();
Lock writeLock = rwLock.writeLock();

readLock.lock();
try {
    // чтение данных
} finally {
    readLock.unlock();
}

writeLock.lock();
try {
    // запись данных
} finally {
    writeLock.unlock();
}
```

## Интерфейс Condition

`Condition` — интерфейс, предоставляющий более гибкие средства ожидания и уведомления потоков, аналогичные методам `wait()`, `notify()`, `notifyAll()`, но работающие с объектами `Lock`.

Основные методы:

- `void await()` — поток ожидает сигнала, освобождая блокировку.
- `void signal()` — пробуждает один ожидающий поток.
- `void signalAll()` — пробуждает все ожидающие потоки.

Для создания объекта `Condition` используется метод `newCondition()` интерфейса `Lock`.

Пример использования:

```java
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();

lock.lock();
try {
    while (!someCondition) {
        condition.await();
    }
    // действия после ожидания
    condition.signalAll();
} finally {
    lock.unlock();
}
```

---

### Итог

| Интерфейс / Класс        | Назначение                                                                                     |
|-------------------------|------------------------------------------------------------------------------------------------|
| `Lock`                  | Интерфейс для более гибкой блокировки, чем `synchronized`. Реализация — `ReentrantLock`        |
| `ReadWriteLock`         | Интерфейс для разделения блокировок на чтение и запись. Реализация — `ReentrantReadWriteLock`  |
| `Condition`             | Интерфейс для организации ожидания и уведомления потоков, аналог `wait/notify` для `Lock`      |

Эти механизмы позволяют тонко управлять синхронизацией и взаимодействием потоков в Java, обеспечивая более высокую гибкость и производительность по сравнению с традиционными средствами.



**Вопрос 31**

Атомарные операции в Java обеспечивают выполнение действий как единого целого без прерываний, что критически важно для многопоточных приложений. Классы из пакета `java.util.concurrent.atomic`, такие как `AtomicInteger`, предоставляют потокобезопасные альтернативы примитивным типам и операциям.  

### Проблема неатомарных операций  
Обычные операции, например `count++`, не являются атомарными. Они включают три шага:  
1. Чтение текущего значения[1][6].  
2. Увеличение на 1.  
3. Запись нового значения[1][6].  

В многопоточной среде два потока могут одновременно прочитать одно значение, что приведет к потере обновлений. Например, если `count = 100`, оба потока запишут 101 вместо 102[1][6].  

### Решение через AtomicInteger  
Класс `AtomicInteger` реализует атомарные операции с помощью механизма **CAS (Compare-And-Swap)**[1][3][4][7].  

#### Пример использования:  
```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet(); // Атомарно увеличивает значение на 1
```

#### Принцип работы CAS:  
1. Получает текущее значение (`current`).  
2. Вычисляет новое значение (`new = current + 1`).  
3. Обновляет значение, только если текущее осталось неизменным (проверка через `compareAndSet(current, new)`)[3][4][7].  

Если проверка проваливается (значение изменилось другим потоком), операция повторяется.  

### Основные методы AtomicInteger  
- `incrementAndGet()`: атомарный инкремент с возвратом нового значения[3][4].  
- `getAndAdd(int delta)`: добавляет `delta` и возвращает старое значение[5][7].  
- `compareAndSet(expected, new)`: обновляет значение, если текущее равно `expected`[3][7].  

### Преимущества перед synchronized  
- **Отсутствие блокировок**: CAS использует низкоуровневые инструкции процессора, что повышает производительность[3][4][7].  
- **Избегание deadlock**: нет взаимных блокировок потоков[3][7].  

### Другие атомарные классы  
- `AtomicLong`: для работы с `long`.  
- `AtomicBoolean`: атомарные булевы операции.  
- `AtomicReference`: для объектов[3][4][7].  

### Ограничения  
- Атомарные классы подходят для простых операций. Сложная логика (например, проверка условий с последующим обновлением) требует комбинации методов (например, `compareAndSet` в цикле)[7].  

Таким образом, `AtomicInteger` и другие классы из `java.util.concurrent.atomic` предоставляют эффективный способ работы с shared-данными в многопоточных сценариях, минимизируя накладные расходы синхронизации.

**Вопрос 32**

Потокобезопасные коллекции в Java обеспечивают корректную работу с данными в многопоточной среде, предотвращая состояния гонок и исключения, связанные с одновременным доступом. Существует два основных подхода к потокобезопасным коллекциям: **synchronized-коллекции** и **concurrent-коллекции**.

## Synchronized-коллекции

- Это обёртки вокруг обычных коллекций, которые синхронизируют все методы для обеспечения безопасности потоков.
- Пример: `Collections.synchronizedList(new ArrayList<>())`, `Collections.synchronizedSet(...)`, `Collections.synchronizedMap(...)`.
- Недостаток: при работе с такими коллекциями одновременно может работать только один поток, что снижает масштабируемость и производительность.
- Итераторы таких коллекций не потокобезопасны сами по себе, поэтому при переборе элементов нужно дополнительно синхронизировать блок кода, чтобы избежать `ConcurrentModificationException`.

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());

synchronized(list) {
    Iterator<String> it = list.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}
```

- При этом составные операции (например, проверка и добавление) требуют дополнительной внешней синхронизации.

## Concurrent-коллекции

- Коллекции из пакета `java.util.concurrent` специально разработаны для эффективной работы в многопоточной среде с минимальной блокировкой.
- Основные классы:

  - **ConcurrentHashMap** — потокобезопасный аналог `HashMap` с высокой степенью параллелизма. Позволяет нескольким потокам одновременно читать и писать без полной блокировки коллекции.
  
  - **CopyOnWriteArrayList** — потокобезопасный аналог `ArrayList`, реализующий стратегию "копирование при записи". При изменении коллекции создаётся новая копия внутреннего массива, что позволяет безопасно и без блокировок перебирать элементы в других потоках. Подходит для коллекций с малым количеством модификаций и большим числом чтений.
  
  - **ConcurrentSkipListMap**, **ConcurrentSkipListSet** — потокобезопасные реализации сортированных коллекций с логарифмическим временем доступа.
  
  - **ConcurrentLinkedQueue**, **ConcurrentLinkedDeque** — неблокирующие очереди и дека для многопоточного доступа.

- Итераторы concurrent-коллекций не выбрасывают `ConcurrentModificationException` и отражают состояние коллекции на момент создания или близко к нему.

## Отличия synchronized- и concurrent-коллекций

| Характеристика            | Synchronized-коллекции                 | Concurrent-коллекции                      |
|---------------------------|--------------------------------------|------------------------------------------|
| Механизм потокобезопасности | Полная синхронизация (блокировка)    | Разделение блокировок, неблокирующие операции, CAS |
| Масштабируемость          | Низкая, один поток за раз             | Высокая, несколько потоков одновременно |
| Итераторы                 | Не потокобезопасны, требуют внешней синхронизации | Потокобезопасны, не вызывают исключений |
| Производительность        | Ниже при высокой конкуренции          | Выше благодаря минимальной блокировке   |
| Пример                   | `Collections.synchronizedList(...)`   | `ConcurrentHashMap`, `CopyOnWriteArrayList` |

## Рекомендации по использованию

- Если требуется простая потокобезопасность и низкая конкуренция — можно использовать synchronized-обёртки.
- Для высоконагруженных многопоточных приложений лучше применять concurrent-коллекции из `java.util.concurrent`.
- Для коллекций с частыми чтениями и редкими изменениями хорошо подходит `CopyOnWriteArrayList`.
- Для ассоциативных массивов с высокой конкуренцией — `ConcurrentHashMap`.

---

Таким образом, потокобезопасные коллекции в Java делятся на синхронизируемые обёртки и специализированные concurrent-реализации. Последние обеспечивают лучшую масштабируемость и удобство работы в многопоточной среде[1][2][4][5].

**Вопрос 33**

Пакет `java.time`, введённый в Java 8, содержит современные, удобные и потокобезопасные классы для работы с датой и временем, которые заменили устаревшие и проблемные классы `java.util.Date` и `java.util.Calendar`.

## Основные классы пакета `java.time`

- **LocalDate** — представляет дату (год, месяц, день) без времени и часового пояса. Объекты неизменяемы (immutable).  
  Пример создания текущей даты:  
  ```java
  LocalDate today = LocalDate.now();
  ```
  Можно создавать дату с конкретными значениями:  
  ```java
  LocalDate date = LocalDate.of(2024, 6, 11);
  ```

- **LocalTime** — представляет время (часы, минуты, секунды, наносекунды) без даты и часового пояса.  
  Пример:  
  ```java
  LocalTime time = LocalTime.now();
  ```

- **LocalDateTime** — сочетает в себе дату и время без часового пояса.  
  Пример:  
  ```java
  LocalDateTime dateTime = LocalDateTime.now();
  LocalDateTime specificDateTime = LocalDateTime.of(2024, 6, 11, 17, 30, 0);
  ```

- **ZonedDateTime** — дата и время с учётом часового пояса. Позволяет работать с временными зонами.  
  Пример:  
  ```java
  ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("Europe/Moscow"));
  ```

- **Instant** — точка во времени в формате UTC (универсальное время). Используется для отметок времени и измерения интервалов.  

- **Period** — период между двумя датами (годы, месяцы, дни).  

- **Duration** — продолжительность времени (часы, минуты, секунды, наносекунды).  

## Особенности и преимущества

- Все классы из `java.time` **immutable** и **потокобезопасны**.  
- Предоставляют богатый набор методов для сложных операций с датой и временем: добавление/вычитание дней, месяцев, лет, сравнение, форматирование и парсинг.  
- Поддержка часовых поясов и интернационализации.  
- Удобный и понятный API, вдохновлённый библиотекой Joda-Time.  

## Пример основных операций с `LocalDate`

```java
LocalDate date = LocalDate.now(); // текущая дата
int year = date.getYear();
int month = date.getMonthValue();
int day = date.getDayOfMonth();

LocalDate newDate = date.plusDays(5); // добавляем 5 дней
LocalDate earlierDate = date.minusMonths(2); // вычитаем 2 месяца
DayOfWeek dayOfWeek = date.getDayOfWeek(); // день недели
```

---

Таким образом, пакет `java.time` — современный стандарт для работы с датой и временем в Java, обеспечивающий удобство, безопасность и гибкость при работе с временными данными. Рекомендуется использовать его вместо устаревших классов для всех новых проектов на Java 8 и выше[1][3][5][6][7][9].

**Вопрос 35**

Конвейеры и Stream API в Java — это мощный инструмент для декларативной и эффективной обработки коллекций и других источников данных.

## Источники конвейера (Stream sources)

Поток (Stream) создаётся из различных источников данных, например:  
- Коллекции (`List`, `Set`, `Map` и др.) через метод `.stream()` или `.parallelStream()`.  
- Массивы через `Arrays.stream(array)`.  
- Генераторы, файлы, каналы ввода-вывода и другие структуры.  

Источник — это начальная точка конвейера, откуда берутся элементы для обработки[1][2][5].

## Конвейер Stream API — структура обработки данных

Конвейер состоит из трёх основных частей:  
1. **Источник данных** — исходная коллекция или другая структура.  
2. **Промежуточные операции** — преобразования, которые возвращают новый поток и могут быть цепочными.  
3. **Терминальная операция** — завершает конвейер, возвращая результат или вызывая побочный эффект (например, сбор в коллекцию, подсчёт, вывод).

### Промежуточные операции

- `filter(Predicate)` — фильтрация элементов по условию.  
- `map(Function)` — преобразование элементов (например, изменение типа или модификация).  
- `sorted()`, `distinct()`, `skip()`, `limit()` и другие — операции для сортировки, удаления дубликатов, пропуска или ограничения количества элементов.  

Промежуточные операции **ленивы** — они не выполняются сразу, а откладываются до вызова терминальной операции[1][2][6].

### Терминальные операции

- `forEach(Consumer)` — обход элементов с выполнением действия.  
- `collect(Collector)` — сбор элементов в коллекцию или другую структуру.  
- `count()`, `min()`, `max()`, `reduce()` — агрегация и вычисления.  
- `anyMatch()`, `allMatch()`, `noneMatch()` — проверка условий.  

Терминальная операция запускает выполнение всего конвейера[1][2].

## Особенности обработки данных в Stream API

- **Ленивость**: операции не выполняются сразу, а только при вызове терминальной операции. Это позволяет оптимизировать обработку и избежать лишних вычислений.  
- **Поэтапная обработка элементов**: каждый элемент проходит последовательно через весь конвейер операций, а не обрабатывается целиком на каждом этапе. Это повышает эффективность и позволяет прерывать обработку, если это возможно.  
- **Одноразовость**: поток можно использовать только один раз. После терминальной операции поток считается исчерпанным.  
- **Параллельность**: можно легко переключиться на параллельный режим с помощью `parallelStream()` или `parallel()`, что позволяет использовать многопроцессорные системы для ускорения обработки[1][2][8].

## Пример конвейера

```java
List<String> list = List.of("one", "two", "three");

list.stream()
    .filter(s -> s.length() <= 3)          // фильтрация по длине
    .map(String::toUpperCase)               // преобразование в верхний регистр
    .forEach(System.out::println);          // вывод результата
```

При этом элементы проходят через все операции по очереди: сначала "one" фильтруется, затем преобразуется, затем выводится, и только потом переходит к следующему элементу[1].

---

Таким образом, Stream API в Java организует обработку данных как конвейер, где данные поступают из источника, проходят через цепочку промежуточных операций и завершаются терминальной операцией. Это обеспечивает декларативность, удобство, ленивость и возможность параллельной обработки данных.


**Вопрос 36**

Коллекторы в Java — это специальные объекты, которые помогают собрать элементы из потока (Stream) в какую-то коллекцию или другую структуру данных. Проще говоря, коллектор берет поток данных и преобразует его в привычный список, множество, карту или даже строку.

### Как это работает максимально просто:

- Вы вызываете у потока метод `collect()`.
- В этот метод передаете коллектор — объект, который знает, как из элементов потока сделать нужную коллекцию.
- Коллектор «собирает» все элементы потока и возвращает готовую коллекцию (например, `List`, `Set`, `Map`) или другой результат.

### Пример:

```java
List<String> list = List.of("apple", "banana", "apple", "orange");

List<String> result = list.stream()
    .filter(s -> s.startsWith("a"))
    .collect(Collectors.toList());  // Коллектор собирает отфильтрованные элементы в список

System.out.println(result);  // [apple, apple]
```

Здесь `Collectors.toList()` — это коллектор, который собирает элементы в список.

---

### Ключевые моменты:

- Коллекторы — это «переход» от потока к коллекции.  
- В Java есть готовые коллекторы в классе `Collectors` для самых распространённых задач: собрать в список, множество, карту, объединить строки и т.д.  
- Они делают работу с потоками удобной и понятной.

Таким образом, коллекторы — это удобный и мощный инструмент для преобразования потоков данных в нужные структуры.  

(Источник: [JavaRush](https://javarush.com/quests/lectures/questsyntaxpro.level18.lecture06))


**Вопрос 37**

Рекурсия в Java — это способ, при котором метод вызывает сам себя для решения задачи. Такой метод называется рекурсивным.

## Основные моменты рекурсии

- **Базовый случай (условие выхода)** — это условие, при котором рекурсивные вызовы прекращаются. Без него рекурсия будет бесконечной и приведёт к ошибке `StackOverflowError`.  
- **Шаг рекурсии** — это вызов метода самого себя с изменёнными параметрами, приближающими к базовому случаю.

## Как это работает

При каждом вызове рекурсивного метода создаётся новый фрейм в стеке вызовов с локальными переменными и параметрами. Когда достигается базовый случай, метод начинает возвращать результаты, и стек постепенно разворачивается.

## Пример: вычисление факториала числа

```java
public static int factorial(int n) {
    if (n <= 1) {           // базовый случай
        return 1;
    } else {
        return n * factorial(n - 1);  // шаг рекурсии
    }
}
```

Вызов `factorial(5)` последовательно вызывает `factorial(4)`, `factorial(3)`, ..., пока не дойдёт до `factorial(1)`, который возвращает 1. Затем результаты умножаются и возвращаются вверх по стеку.

## Пример: вывод чисел от n до 1

```java
public static void countDown(int n) {
    if (n <= 0) {
        System.out.println("Boom!");
    } else {
        System.out.println(n);
        countDown(n - 1);
    }
}
```

## Когда использовать рекурсию

- Для решения задач, которые естественно разбиваются на одинаковые подзадачи (например, вычисление факториала, чисел Фибоначчи, обход деревьев, сортировка).  
- Когда код с рекурсией получается проще и понятнее, чем с циклами.

## Важные замечания

- Рекурсивный метод должен иметь корректный базовый случай.  
- Нужно следить за глубиной рекурсии, чтобы не вызвать переполнение стека.  
- Иногда рекурсия может быть менее эффективна, чем итерация, из-за накладных расходов на вызовы методов.

---

Таким образом, рекурсия — это метод программирования, при котором функция решает задачу, вызывая сама себя с меньшими параметрами, пока не достигнет простого базового случая. Это мощный и часто используемый приём в Java.  

(Источники: [1], [2], [3], [4], [5], [6])


*Вопрос 38*

Регулярные выражения (RegEx) в Java — это шаблоны, которые используются для поиска, проверки и обработки текста по определённым правилам. Проще говоря, это способ задать правило, которому должна соответствовать строка или её часть.

В Java для работы с регулярными выражениями используются два основных класса из пакета `java.util.regex`: **Pattern** и **Matcher**.

---

## Класс Pattern

- Представляет **скомпилированное регулярное выражение** (шаблон).  
- Компиляция шаблона в объект Pattern повышает производительность при многократном использовании.  
- Создаётся с помощью статического метода:  
  ```java
  Pattern pattern = Pattern.compile("ваш_шаблон");
  ```
- Если регулярное выражение содержит ошибки, при компиляции выбрасывается исключение `PatternSyntaxException`.  
- Предоставляет методы для получения исходного шаблона, проверки соответствия строки и создания объекта Matcher.

---

## Класс Matcher

- Объект класса Matcher создаётся на основе Pattern и строки, в которой ищутся совпадения:  
  ```java
  Matcher matcher = pattern.matcher("исходный текст");
  ```
- Выполняет операции поиска и сопоставления по шаблону.  
- Основные методы:  
  - `boolean matches()` — возвращает `true`, если вся строка полностью соответствует шаблону.  
  - `boolean find()` — ищет следующее совпадение в строке, можно вызывать многократно для поиска всех совпадений.  
  - `boolean find(int start)` — начинает поиск с позиции `start`.  
  - `String group()` — возвращает найденное совпадение.  
  - `int start()`, `int end()` — позиции найденного совпадения в исходной строке.  
  - `reset()` — сбрасывает состояние Matcher для повторного поиска.

---

## Пример использования

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class RegexExample {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile("\\d+"); // шаблон для поиска чисел
        Matcher matcher = pattern.matcher("abc123def456");

        while (matcher.find()) {
            System.out.println("Найдено число: " + matcher.group() +
                               " с позиции " + matcher.start());
        }
    }
}
```

Вывод:  
```
Найдено число: 123 с позиции 3
Найдено число: 456 с позиции 9
```

---

## Кратко

- **Pattern** — это скомпилированный шаблон регулярного выражения.  
- **Matcher** — объект, который ищет совпадения этого шаблона в заданной строке.  
- Вместе они позволяют выполнять мощный и эффективный поиск, проверку и замену текста с помощью регулярных выражений.

---

Эти классы являются основой для работы с регулярными выражениями в Java и широко применяются для валидации данных, парсинга текста и других задач обработки строк.

**Вопрос 39 - 40**

## 39. Порождающие паттерны проектирования (Creational Patterns)

Порождающие паттерны отвечают за процесс создания объектов, обеспечивая гибкость, повторное использование и инкапсуляцию логики создания.

### Основные порождающие паттерны:

- **Singleton (Одиночка)**  
  Гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.  
  Пример: класс, управляющий конфигурацией приложения или подключением к базе данных.

- **Factory Method (Фабричный метод)**  
  Определяет интерфейс для создания объектов, позволяя подклассам решать, какой класс инстанциировать. Устраняет жёсткую привязку к конкретным классам.  
  Пример: фабрика пицц, создающая разные виды пиццы по запросу.
  
- **Prototype (Прототип)**  
  Позволяет создавать новые объекты путём копирования существующих, не вдаваясь в детали их реализации.  
  Пример: клонирование объектов с помощью метода `clone()`.

---

## 40. Поведенческие паттерны проектирования (Behavioral Patterns)

Поведенческие паттерны определяют способы взаимодействия и распределения обязанностей между объектами.

### Основные поведенческие паттерны и примеры:


- **Command (Команда)**  
  Инкапсулирует запрос в объект, позволяя параметризовать методы вызова, ставить запросы в очередь и поддерживать отмену операций.  
  Пример: кнопки Undo/Redo.

- **Iterator (Итератор)**  
  Обеспечивает последовательный обход элементов коллекции без раскрытия её внутреннего устройства.  
  Пример: перебор элементов списка.

- **Visitor (Посетитель)**  
  Позволяет добавлять новые операции к объектам без изменения их классов.  
  Пример: обход сложной структуры объектов с разными операциями.

---

### Кратко

| Категория           | Основные паттерны                                | Задача                                          |
|---------------------|-------------------------------------------------|------------------------------------------------|
| **Порождающие**     | Singleton, Factory Method, Abstract Factory, Builder, Prototype | Управление созданием объектов                   |
| **Поведенческие**   | Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor | Организация взаимодействия и поведения объектов |

---

Эти паттерны помогают создавать гибкие, расширяемые и поддерживаемые приложения, решая типичные задачи проектирования.  

## Структурные паттерны проектирования — что это?

Структурные паттерны отвечают за организацию классов и объектов в более крупные и удобные для поддержки структуры. Они помогают упростить архитектуру, сделать код гибким и расширяемым, а также позволяют объектам с несовместимыми интерфейсами работать вместе.

---

## Основные структурные паттерны и их примеры

| Паттерн       | Описание                                                                                   | Пример из жизни или кода                                      |
|---------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------|
| **Adapter (Адаптер)**    | Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом. Позволяет работать с несовместимыми интерфейсами. | Переходник с европейской вилки на американскую розетку. В коде — адаптер, который преобразует вызовы одного API в другой. |
| **Bridge (Мост)**       | Разделяет абстракцию и реализацию на две иерархии, позволяя изменять их независимо.        | Отделение интерфейса пульта управления от конкретной техники (телевизор, кондиционер). |
| **Composite (Компоновщик)** | Объединяет объекты в древовидную структуру и позволяет работать с отдельными объектами и группами одинаково. | Файловая система: файлы и папки, где папка может содержать файлы и другие папки. |
| **Decorator (Декоратор)** | Динамически добавляет объектам новую функциональность, оборачивая их в «обёртки».          | Украшение подарка: обернуть коробку в бумагу, добавить ленту, не меняя сам подарок. В коде — добавление поведения объекту без наследования. |
| **Facade (Фасад)**       | Предоставляет простой интерфейс к сложной системе, скрывая её внутреннюю сложность.         | Оплата через Apple Pay — упрощённый интерфейс к множеству сложных операций. В коде — единый интерфейс к сложной библиотеке. |
| **Flyweight (Приспособленец)** | Экономит память, разделяя общее состояние между множеством объектов.                     | Шрифты в текстовом редакторе: одна копия глифа используется для всех одинаковых символов. |
| **Proxy (Заместитель)**  | Создаёт объект-заменитель, который контролирует доступ к другому объекту, перехватывая вызовы. | Виртуальный прокси для ленивой загрузки изображения или защиты доступа. |

---

## Краткие примеры

- **Adapter:**  
  ```java
  // Интерфейс европейской вилки
  interface EuroPlug {
      void connect();
  }
  
  // Американская розетка
  class USSocket {
      void powerOn() { System.out.println("Power on"); }
  }
  
  // Адаптер
  class Adapter implements EuroPlug {
      private USSocket socket;
      Adapter(USSocket socket) { this.socket = socket; }
      public void connect() { socket.powerOn(); }
  }
  ```

- **Decorator:**  
  ```java
  interface Coffee {
      String getDescription();
      double cost();
  }
  
  class SimpleCoffee implements Coffee {
      public String getDescription() { return "Simple coffee"; }
      public double cost() { return 1.0; }
  }
  
  class MilkDecorator implements Coffee {
      private Coffee coffee;
      MilkDecorator(Coffee coffee) { this.coffee = coffee; }
      public String getDescription() { return coffee.getDescription() + ", milk"; }
      public double cost() { return coffee.cost() + 0.5; }
  }
  ```

---

## Итог

Структурные паттерны помогают строить сложные системы из простых компонентов, улучшая читаемость, расширяемость и повторное использование кода. Они часто применяются для интеграции разных подсистем, оптимизации ресурсов и упрощения интерфейсов.

---












