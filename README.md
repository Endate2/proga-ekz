**Вопрос 1**

Параметризованные типы, также известные как обобщения, позволяют объявлять классы, интерфейсы и методы, в которых тип данных указывается в виде параметра[7][8]. Использование параметризованных типов обеспечивает типовую безопасность[1][10].

**Создание параметризованных классов**
1.  **Объявление:** Параметризованный класс объявляется так же, как и обычный класс, но с добавлением раздела параметров типа после имени класса[6]. Раздел параметров типа состоит из одного или нескольких параметров типа, разделенных запятыми[6].
    ```java
    class ИмяКласса<T> {
        // ...
    }
    ```
2.  **Параметры типа:** В угловых скобках `<>` указывается имя параметра типа, которое используется в качестве заполнителя для реального типа, передаваемого классу при создании экземпляра[8].
3.  **Использование:** Внутри класса параметр типа может использоваться для объявления переменных, параметров методов и возвращаемых типов[7].
    ```java
    class Generics<T> {
        T ob;
        Generics(T o) {
            ob = o;
        }
        T getObject() {
            return ob;
        }
    }
    ```
4.  **Инстанцирование:** При создании экземпляра параметризованного класса необходимо указать конкретный тип данных, который будет использоваться[7].
    ```java
    Generics<Integer> iObject = new Generics<>(777);
    Generics<String> strOb = new Generics<>("Обобщенный текст");
    ```
5.  **Примеры параметризованных классов**:
    *   Очередь (Queue): параметризованная очередь, работающая с любыми типами данных[9].
    *   Хранилище (Storage): универсальное хранилище элементов любого типа[9].
    *   Пара (Pair): способ хранения двух связанных переменных разных типов[9].

Параметризованные классы могут быть частью иерархии классов, выступая в качестве суперкласса или подкласса[7]. В параметризованной иерархии любые аргументы типов, необходимые параметризованному суперклассу, должны передаваться всеми подклассами по иерархии вверх[7].

**Вопрос 2**

Параметризованные методы позволяют использовать один и тот же метод с разными типами данных[3][5]. Ограничения типов позволяют указать, какие типы данных могут быть использованы в параметризованных методах[5]. Вы интересуетесь объектно-ориентированным программированием, особенно параметризованными классами и ограничениями типов[9].

**Работа с параметризованными методами**

1.  **Объявление:** Параметризованные методы объявляются с использованием раздела параметров типа перед типом возвращаемого значения[5].
    ```java
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    ```
2.  **Вызов:** При вызове параметризованного метода тип можно указать явно или позволить компилятору вывести его[6].
    ```java
    printArray(intArray); // Выведет: 1 2 3
    printArray(strArray); // Выведет: Hello World
    ```

**Ограничение типа сверху**

1.  **Ключевое слово `extends`:** Ограничение сверху указывает, что тип должен быть подклассом указанного класса или интерфейса[5].
    ```java
    public static <T extends Number> byte asByte(T num) {
        long n = num.longValue();
        if (n >= -128 && n <= 127) return (byte)n;
        else return 0;
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть подклассом класса `Number`[5]. Это позволяет использовать метод `doubleValue()` для преобразования значения объектов типа `T` в тип `double`[6].

**Ограничение типа снизу**

1.  **Ключевое слово `super`:** Ограничение снизу указывает, что тип должен быть суперклассом указанного класса[5].
    ```java
    public static <T super Integer> void processElements(List<T> list) {
        // ...
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть суперклассом класса `Integer`. Это позволяет методу работать со списками, которые могут содержать `Integer` или его суперклассы.


**Вопрос 3**

Класс **Number** в Java — это абстрактный суперкласс для всех числовых классов-оберток, таких как Integer, Double, Float, Long, Byte и Short. Он определяет методы для преобразования числовых значений в разные примитивные типы: `byteValue()`, `doubleValue()`, `floatValue()`, `intValue()`, `longValue()`, `shortValue()`[2].

**Классы-обертки (Wrappers)** — это классы, которые "оборачивают" примитивные типы данных в объекты. Например:
- `Integer` — обертка для `int`
- `Double` — обертка для `double`
- `Character` — обертка для `char`
- `Boolean` — обертка для `boolean`

Эти классы позволяют использовать примитивы там, где необходимы объекты, например, в коллекциях.

**Автоупаковка (autoboxing)** — это автоматическое преобразование примитивного типа в соответствующий объект-обертку. Например, при присваивании значения типа `int` переменной типа `Integer` компилятор автоматически создает объект `Integer`.

```java
Integer i = 5; // автоупаковка int в Integer
```

**Автораспаковка (unboxing)** — обратный процесс, когда объект-обертка автоматически преобразуется в примитивный тип.

```java
int n = i; // автораспаковка Integer в int
```

Таким образом, автоупаковка и автораспаковка упрощают работу с примитивами и объектами, устраняя необходимость явного создания объектов-оберток или вызова методов для получения примитивных значений[2].

Важной особенностью является то, что все классы-обертки наследуются от `Number` (кроме `Character` и `Boolean`, которые не являются числовыми), что позволяет использовать их в обобщениях и методах с ограничениями по типу, например `<T extends Number>`[2][6].

**Вопрос 4**

В Java коллекции представляют собой структуры данных для хранения и управления группами однородных элементов. Основные виды коллекций и их интерфейсы:

## Виды коллекций и основные интерфейсы

- **List**  
  Упорядоченный список элементов, допускающий дубликаты. Каждый элемент имеет индекс. Позволяет получать, добавлять и удалять элементы по индексу.  
  Основные реализации: `ArrayList`, `LinkedList`, `Vector`.  
  Особенности: поддержка итератора `ListIterator`, который умеет перемещаться вперед и назад по списку.  
  [1][2][7]

- **Set**  
  Коллекция уникальных элементов, не допускающая дубликатов. Порядок элементов не гарантируется (в зависимости от реализации).  
  Основные реализации: `HashSet`, `TreeSet`, `LinkedHashSet`.  
  [1][2]

- **Queue**  
  Коллекция, работающая по принципу «первым пришел — первым вышел» (FIFO). Используется для организации очередей.  
  Основные реализации: `LinkedList`, `PriorityQueue`.  
  [1][2]

- **Deque**  
  Расширяет интерфейс `Queue` и представляет двунаправленную очередь, где элементы можно добавлять и удалять с обоих концов.  
  Основные реализации: `ArrayDeque`, `LinkedList`.  
  [2]

- **Map**  
  Коллекция пар «ключ-значение», где ключи уникальны. Не наследуется от `Collection`, но тесно связана с коллекциями.  
  Основные реализации: `HashMap`, `TreeMap`, `LinkedHashMap`.  
  [1][2][5]

## Иерархия и особенности

- Интерфейс `Collection` — базовый для `List`, `Set` и `Queue`.  
- Интерфейс `Iterable` — корневой для всех коллекций, обеспечивает возможность перебора элементов.  
- `Map` не входит в иерархию `Collection`, но является ключевой структурой данных для хранения ассоциативных пар.  
[2][5][6]

## Краткое сравнение

| Интерфейс | Описание                          | Особенности                          | Примеры реализаций          |
|-----------|---------------------------------|------------------------------------|----------------------------|
| List      | Упорядоченный список с дубликатами | Индексированный доступ, дубликаты разрешены | ArrayList, LinkedList, Vector |
| Set       | Множество уникальных элементов   | Нет дубликатов, порядок не гарантируется | HashSet, TreeSet, LinkedHashSet |
| Queue     | Очередь FIFO                    | Добавление в конец, удаление из начала | LinkedList, PriorityQueue   |
| Deque     | Двунаправленная очередь          | Добавление/удаление с обоих концов | ArrayDeque, LinkedList      |
| Map       | Коллекция пар ключ-значение      | Уникальные ключи, быстрый поиск по ключу | HashMap, TreeMap, LinkedHashMap |

Таким образом, выбор коллекции зависит от требований к упорядочиванию, уникальности элементов и способу доступа к данным. Коллекции в Java обеспечивают гибкие и эффективные инструменты для работы с различными структурами данных.  
[1][2][5][6][7]

**Вопрос 5**

Для обхода элементов коллекций в Java используются интерфейсы **Iterable**, **Iterator** и **ListIterator**, которые обеспечивают последовательный доступ к элементам без раскрытия внутренней структуры коллекции.

## Интерфейс Iterable

- Это базовый интерфейс, реализуемый всеми коллекциями, который позволяет получить итератор для обхода элементов.  
- Определяет метод `iterator()`, возвращающий объект типа `Iterator`.  
- Позволяет использовать цикл `for-each` для удобного перебора элементов коллекции.

## Интерфейс Iterator

- Предоставляет методы для последовательного обхода коллекции:  
  - `boolean hasNext()` — проверяет, есть ли следующий элемент;  
  - `E next()` — возвращает следующий элемент;  
  - `void remove()` — удаляет текущий элемент из коллекции (после вызова `next()`).  
- Итератор позволяет безопасно проходить по коллекции, получать и удалять элементы во время обхода.  
- Получается через метод `iterator()` коллекции.  
- Пример использования:
  ```java
  Iterator<String> it = collection.iterator();
  while (it.hasNext()) {
      String element = it.next();
      System.out.println(element);
  }
  ```

## Интерфейс ListIterator

- Расширяет `Iterator` и предназначен для обхода списков (`List`).  
- Добавляет возможность двунаправленной итерации:  
  - `boolean hasPrevious()` и `E previous()` — для движения назад по списку;  
- Позволяет получать индексы элементов:  
  - `int nextIndex()`, `int previousIndex()`;  
- Поддерживает изменение коллекции во время обхода:  
  - `void add(E e)` — вставка элемента;  
  - `void set(E e)` — замена текущего элемента;  
  - `void remove()` — удаление текущего элемента;  
- Получается через метод `listIterator()` списка.  
- Пример двунаправленного обхода:
  ```java
  ListIterator<String> listIt = list.listIterator();
  while (listIt.hasNext()) {
      System.out.println(listIt.next());
  }
  while (listIt.hasPrevious()) {
      System.out.println(listIt.previous());
  }
  ```

Таким образом, интерфейс **Iterable** обеспечивает получение итератора, **Iterator** позволяет последовательно обходить и изменять коллекцию, а **ListIterator** расширяет эти возможности для списков, предоставляя двунаправленную навигацию и дополнительные методы модификации элементов[1][2][3][4][7].

**Вопрос 6**

Для сортировки элементов коллекций в Java используются интерфейсы **Comparable** и **Comparator**, которые задают правила сравнения объектов.

## Интерфейс Comparable

- Определяет естественный порядок сортировки объектов класса.  
- Класс, объекты которого нужно сортировать, должен реализовать интерфейс `Comparable<T>` и переопределить метод:
  ```java
  int compareTo(T o);
  ```
- Метод `compareTo` возвращает отрицательное число, ноль или положительное число, если текущий объект меньше, равен или больше объекта `o`.  
- Пример:
  ```java
  public class Person implements Comparable<Person> {
      private int age;
      @Override
      public int compareTo(Person other) {
          return Integer.compare(this.age, other.age);
      }
  }
  ```
- Используется, когда сортировка всегда должна происходить по одному критерию — "естественному порядку".  
- Коллекции, такие как `TreeSet` и `TreeMap`, требуют реализации `Comparable` для автоматической сортировки элементов[1][2][5].

## Интерфейс Comparator

- Позволяет задавать альтернативные или дополнительные правила сортировки, не изменяя исходный класс.  
- Реализуется в отдельном классе или с помощью лямбда-выражений.  
- Определяет метод:
  ```java
  int compare(T o1, T o2);
  ```
- Позволяет сортировать по разным атрибутам или нескольким критериям, комбинируя компараторы через `thenComparing`.  
- Пример сортировки по имени и отделу:
  ```java
  Collections.sort(students, Comparator.comparing(Student::getDepartment)
                                       .thenComparing(Student::getName));
  ```
- Можно создавать компараторы "на лету" через статический метод `Comparator.comparing()` и использовать методы для обработки `null` и обратного порядка.  
- Обеспечивает гибкость и расширяемость сортировки без изменения класса объектов[1][3][6].

## Итоги и рекомендации

| Особенность               | Comparable                         | Comparator                          |
|--------------------------|----------------------------------|-----------------------------------|
| Где реализуется           | В самом классе                   | В отдельном классе или лямбдами   |
| Количество критериев      | Один (естественный порядок)      | Несколько, комбинируемые          |
| Изменение исходного класса| Требуется                       | Не требуется                      |
| Использование             | Для коллекций с естественным порядком | Для гибкой и многоуровневой сортировки |

Таким образом, если нужна простая сортировка по одному критерию — реализуйте `Comparable`. Если требуется несколько вариантов сортировки или сложная логика — используйте `Comparator`[1][2][3][6].

**Вопрос 7**

Интерфейс **List** в Java представляет собой упорядоченную коллекцию, которая допускает хранение дубликатов и обеспечивает доступ к элементам по индексу. Он расширяет интерфейс **Collection** и добавляет методы для работы с позициями элементов, такие как вставка, замена, сортировка и получение подсписков[3][5][8].

## Интерфейс List

- Хранит элементы в порядке добавления.
- Позволяет обращаться к элементам по индексу.
- Поддерживает дубликаты.
- Основные методы:  
  - `add(int index, E element)` — вставка элемента по индексу;  
  - `set(int index, E element)` — замена элемента по индексу;  
  - `get(int index)` — получение элемента по индексу;  
  - `subList(int start, int end)` — получение подсписка;  
  - `sort(Comparator<? super E> c)` — сортировка списка.

## Класс ArrayList

- Реализация интерфейса List на основе динамического массива.  
- Позволяет быстро получать доступ к элементам по индексу (операция за O(1)).  
- При добавлении элементов в конец может расширять внутренний массив (копирование данных при увеличении размера).  
- Медленнее при вставке и удалении элементов в середине списка, так как требует сдвига элементов.  
- Поддерживает хранение любых ссылочных типов, включая `null`.  
- Часто используется благодаря хорошему балансу производительности и удобству.  
- Конструкторы:  
  - `ArrayList()` — с начальной емкостью 10;  
  - `ArrayList(int initialCapacity)` — с заданной емкостью;  
  - `ArrayList(Collection<? extends E> c)` — создание из другой коллекции[2][3][6].

## Класс LinkedList

- Реализация интерфейса List на основе двусвязного списка.  
- Позволяет эффективно вставлять и удалять элементы в любом месте списка (операции за O(1), если известна позиция).  
- Медленнее при доступе по индексу, так как требует последовательного обхода (операция за O(n)).  
- Также реализует интерфейс Queue и Deque, позволяя использовать его как очередь или двунаправленную очередь.  
- Подходит, когда требуется много вставок и удалений, а быстрый доступ по индексу не критичен[7][8].

## Сравнение ArrayList и LinkedList

| Характеристика           | ArrayList                          | LinkedList                      |
|-------------------------|----------------------------------|--------------------------------|
| Основная структура       | Динамический массив               | Двусвязный список              |
| Доступ по индексу        | Быстрый (O(1))                   | Медленный (O(n))               |
| Вставка/удаление в середине | Медленная (сдвиг элементов)      | Быстрая (перенастройка ссылок)|
| Использование памяти     | Меньше (массив)                  | Больше (узлы с указателями)    |
| Дополнительные интерфейсы| Нет                             | Реализует Queue и Deque        |

## Рекомендации по использованию

- Используйте **ArrayList**, если требуется быстрый доступ по индексу и операции вставки/удаления преимущественно в конце списка.  
- Используйте **LinkedList**, если часто выполняются вставки и удаления в середине коллекции и не важен быстрый доступ по индексу.

## Пример создания и использования ArrayList

```java
List<String> list = new ArrayList<>();
list.add("яблоко");
list.add("банан");
list.add("вишня");
System.out.println(list.get(1)); // банан
```

Таким образом, интерфейс **List** обеспечивает удобную работу с упорядоченными коллекциями, а классы **ArrayList** и **LinkedList** предоставляют разные реализации, оптимизированные под разные сценарии использования[2][3][7][8].



**Вопрос 8**

Интерфейсы **Map** и **SortedMap** в Java представляют коллекции пар «ключ-значение», но отличаются по функциональности и способу хранения данных.

## Интерфейс Map

- Представляет коллекцию пар «ключ-значение», где каждому ключу сопоставлено одно значение.  
- Ключи уникальны, значения могут повторяться.  
- Не наследуется от `Collection`, но является частью Java Collections Framework.  
- Основные методы:  
  - `put(K key, V value)` — добавить или заменить пару;  
  - `get(Object key)` — получить значение по ключу;  
  - `containsKey(Object key)` — проверить наличие ключа;  
  - `remove(Object key)` — удалить пару по ключу;  
  - `entrySet()` — получить набор пар `Map.Entry<K,V>` для перебора.  

## Интерфейс SortedMap

- Расширяет интерфейс `Map`.  
- Гарантирует, что элементы хранятся в отсортированном порядке по ключам (естественный порядок или с помощью `Comparator`).  
- Добавляет методы для работы с диапазонами ключей и навигации:  
  - `firstKey()`, `lastKey()` — получить первый и последний ключ;  
  - `headMap(K toKey)`, `tailMap(K fromKey)`, `subMap(K fromKey, K toKey)` — получить части отображения по диапазонам ключей;  
  - `comparator()` — получить используемый компаратор (или `null`, если используется естественный порядок).  

## Класс HashMap

- Реализация интерфейса `Map` на основе хэш-таблицы.  
- Обеспечивает быстрый доступ, вставку и удаление элементов (в среднем за O(1)).  
- Не гарантирует порядок элементов.  
- Позволяет один `null` ключ и несколько `null` значений.  
- Подходит для большинства задач, где порядок не важен, а нужна высокая производительность.

## Класс TreeMap

- Реализация интерфейса `SortedMap` (а также `NavigableMap`) на основе красно-черного дерева.  
- Хранит элементы в отсортированном порядке по ключам.  
- Операции вставки, удаления и поиска выполняются за O(log n).  
- Требует, чтобы ключи были сравнимы (реализовали `Comparable`) или чтобы при создании передавался `Comparator`.  
- Предоставляет расширенный функционал навигации по ключам: поиск ближайших ключей, удаление первого/последнего элемента и др.  
- Используется, когда важен отсортированный порядок ключей и возможность работы с диапазонами.

## Итоговое сравнение

| Характеристика       | HashMap                         | TreeMap                          |
|---------------------|--------------------------------|---------------------------------|
| Интерфейс           | Map                            | SortedMap, NavigableMap          |
| Структура данных    | Хэш-таблица                    | Красно-черное дерево             |
| Порядок элементов   | Не гарантируется               | Отсортирован по ключам           |
| Сложность операций  | O(1) в среднем                 | O(log n)                        |
| Поддержка null      | Ключ — 1 null, значения — несколько | Ключи null не поддерживаются    |
| Дополнительные методы| Нет                           | Методы работы с диапазонами и навигации по ключам |

Таким образом, **HashMap** — это быстрая и простая реализация для хранения пар без порядка, а **TreeMap** — для случаев, когда важен отсортированный порядок ключей и расширенные возможности навигации.

---



**Вопрос 9**

В Java интерфейсы `Set` и `SortedSet` используются для представления наборов уникальных элементов, при этом `SortedSet` дополнительно обеспечивает их упорядочивание. `HashSet` и `TreeSet` — это классы, реализующие эти интерфейсы[9].

**Интерфейс Set**
*   Представляет собой набор уникальных элементов, не допускающий дублирования[3][4].
*   Не добавляет новых методов, а изменяет унаследованные, например, метод `add()` возвращает `true`, только если элемент еще не содержится в коллекции[3][4].
*   Реализован классами `HashSet`, `TreeSet` и `LinkedHashSet`[9].

**Интерфейс SortedSet**
*   Расширяет интерфейс `Set` и представляет собой упорядоченное множество, элементы которого отсортированы по возрастанию или в соответствии с `Comparator`[6].
*   Содержит методы для работы с упорядоченными данными, такие как `comparator()`, `first()`, `last()`, `headSet()`, `subSet()`, `tailSet()`[6].

**Класс HashSet**
*   Реализует интерфейс `Set` и хранит элементы в хеш-таблице[1][4].
*   Не гарантирует порядок элементов при переборе[1][2].
*   Может хранить `NULL` значения[2].
*   Для создания объекта `HashSet` можно использовать следующие конструкторы[3]:
    *   `HashSet()`: создает пустой список.
    *   `HashSet(Collection<? extends E> col)`: создает хеш-таблицу, добавляя все элементы из указанной коллекции.
    *   `HashSet(int capacity)`: создает хеш-таблицу с указанной начальной емкостью (по умолчанию 16).
    *   `HashSet(int capacity, float koef)`: создает хеш-таблицу с указанной начальной емкостью и коэффициентом заполнения (от 0.0 до 1.0).

**Класс TreeSet**
*   Реализует интерфейс `SortedSet` и хранит элементы в отсортированном порядке[6].
*   Элементы хранятся в отсортированном порядке по возрастанию[6].
*   Операции удаления и вставки выполняются медленнее, чем в `HashSet`, но быстрее, чем в списках[6].
*   Реализует интерфейс `NavigableSet`[8].
*   Конструкторы класса `TreeSet`[6]:
    *   `TreeSet()`
    *   `TreeSet(Collection<? extends Е> сollection)`
    *   `TreeSet(Comparator<? super Е> соmрarator)`
    *   `TreeSet(SortedSet<E> sortedSet)`

Как вы изучаете структуры данных в Java[10], важно понимать, как `HashSet` и `TreeSet` реализуют интерфейсы `Set` и `SortedSet`[9].



**Вопрос 10**

В Java интерфейсы `Queue` и `Deque` являются частью Collections Framework и предоставляют способы хранения и управления элементами в определенном порядке[4][5]. Классы `PriorityQueue` и `ArrayDeque` являются реализациями этих интерфейсов.

**Интерфейс Queue**
*   Представляет собой коллекцию, предназначенную для хранения элементов в порядке "первым пришел — первым вышел" (FIFO)[4][5].
*   Определяет методы для добавления (`add()`, `offer()`), удаления (`remove()`, `poll()`) и просмотра (`element()`, `peek()`) элементов[5][6].
*   `Queue` является однонаправленной очередью, где элементы добавляются в конец, а извлекаются из начала[1].

**Интерфейс Deque**
*   Расширяет интерфейс `Queue` и представляет собой двустороннюю очередь, позволяющую добавлять и удалять элементы с обоих концов[2][4].
*   Поддерживает как FIFO, так и LIFO (стек) операции[4][5].
*   Предоставляет методы для добавления (`addFirst()`, `addLast()`, `offerFirst()`, `offerLast()`), удаления (`removeFirst()`, `removeLast()`, `pollFirst()`, `pollLast()`) и просмотра (`getFirst()`, `getLast()`, `peekFirst()`, `peekLast()`) элементов с обеих сторон[1][5][7].
*   `Deque` не имеет явно выраженного конца и начала и может расти и уменьшаться в обоих направлениях[8].

**Класс PriorityQueue**
*   Реализует интерфейс `Queue`[6].
*   Представляет собой очередь с приоритетами, где элементы упорядочены в соответствии с их приоритетом[6].
*   Основан на структуре данных "двоичная куча", обеспечивающей быструю вставку и удаление элементов за \$$ O(log n) \$$[6].
*   Удаляет элемент с наивысшим приоритетом (наименьший элемент, если не задан компаратор)[6].
*   Для определения приоритета элементов можно использовать `Comparator`[6].

**Класс ArrayDeque**

*   Реализует интерфейс `Deque`[6].
*   Реализован на основе массива, что делает его эффективным для использования в качестве стека или очереди[6].
*   Поддерживает добавление и удаление элементов с обоих концов за константное время[6].
*   `LinkedList` и `ArrayDeque` напрямую наследуют от `Deque`, а не от `Queue`[3].

Поскольку вас интересует объектно-ориентированное программирование и Java [9][10], важно понимать, как эти интерфейсы и классы реализуют принципы полиморфизма и абстракции.

**Вопрос 11**

В Java 21 появились новые интерфейсы для работы с упорядоченными коллекциями: `SequencedCollection` и `SequencedSet`[1][2][3].

**Интерфейс SequencedCollection**
*   Расширяет интерфейс `Collection`, добавляя методы для манипуляции с первым и последним элементами, а также для инвертирования коллекции[1][2][5].
*   Поддерживает операции как в начале, так и в конце списка, и является обратимой[3].
*   Определяет порядок элементов, располагая их линейно от первого до последнего[3].
*   Содержит методы: `addFirst()`, `addLast()`, `getFirst()`, `getLast()`, `removeFirst()`, `removeLast()`, `reversed()`[2].

Реализации `SequencedCollection`:
*   `List` (`ArrayList` и `LinkedList`)[1][2]
*   `Deque`
*   `SequencedSet`[8]

**Интерфейс SequencedSet**
*   Является под интерфейсом `SequencedCollection`[1].
*   Переопределяет метод `reversed()`, возвращая `SequencedSet` вместо `SequencedCollection`[1].

Реализации `SequencedSet`:
*   `LinkedHashSet` (сохраняет порядок добавления)[1]
*   `TreeSet` (сортирует в алфавитном порядке)[1]

**Класс HashSet**
*   Не поддерживает интерфейс `SequencedSet`, так как не обеспечивает порядок[1].

**Класс LinkedHashSet**
*   Реализует интерфейс `SequencedSet` и сохраняет порядок добавления элементов[1].
*   Поддерживает методы `addFirst()` и `addLast()`[1].

**Класс TreeSet**
*   Реализует интерфейс `SequencedSet` и сортирует элементы в алфавитном порядке[1].
*   Не поддерживает методы `addFirst()` и `addLast()`, так как сам определяет порядок элементов[1].
*   Поддерживает удаление первого и последнего элемента[1].

Поскольку вы интересуетесь объектно-ориентированным программированием и Java[9][10], важно понимать, как эти новые интерфейсы расширяют возможности работы с коллекциями, особенно с учетом вашего интереса к интерфейсам и очередям[11].


**Вопрос 12**

В Java классы `Collections`, `Arrays` и `Objects` предоставляют набор статических методов для удобной работы с коллекциями, массивами и объектами соответственно.

## Класс Collections
*   Содержит статические методы для работы с коллекциями (`Collection`, `List`, `Set` и др.).
*   Основные методы:
    *   `addAll(Collection<? super T> c, T... elements)` — добавляет все указанные элементы в коллекцию.
    *   `binarySearch(List<? extends Comparable<? super T>> list, T key)` — выполняет бинарный поиск элемента в отсортированном списке.
    *   `copy(List<? super T> dest, List<? extends T> src)` — копирует элементы из одного списка в другой.
    *   `max(Collection<? extends T> coll)` и `min(Collection<? extends T> coll)` — возвращают максимальный и минимальный элемент коллекции согласно естественному порядку.
    *   `reverse(List<?> list)` — изменяет порядок элементов списка на обратный.
    *   `shuffle(List<?> list)` — случайным образом перемешивает элементы списка.
    *   `sort(List<T> list)` — сортирует список по естественному порядку.
    *   `replaceAll(List<T> list, T oldVal, T newVal)` — заменяет все вхождения одного элемента на другой.
*   Методы работают с интерфейсами коллекций, обеспечивая гибкость и переиспользуемость[3][6].

## Класс Arrays
*   Предназначен для работы с массивами примитивных и ссылочных типов.
*   Основные методы:
    *   `sort()` — сортировка массива целиком или его части.
    *   `binarySearch()` — бинарный поиск в отсортированном массиве.
    *   `equals()` — сравнение содержимого двух массивов (поэлементное сравнение).
    *   `deepEquals()` — сравнение многомерных массивов по содержимому.
    *   `toString()` и `deepToString()` — преобразование массива в строку для вывода.
    *   `copyOf()` и `copyOfRange()` — копирование массива или его части.
    *   `compare()` — сравнение двух массивов примитивных типов с возвратом порядка.
    *   `mismatch()` — поиск первого индекса, где массивы отличаются.
*   Методы упрощают выполнение часто повторяющихся операций с массивами[2][4][5][6].

## Класс Objects
*   Предоставляет утилитарные методы для работы с объектами.
*   Основные методы:
    *   `equals(Object a, Object b)` — безопасное сравнение объектов с учетом `null`.
    *   `hashCode(Object o)` — вычисление хеш-кода объекта с защитой от `null`.
    *   `requireNonNull(T obj)` — проверка на `null`, выбрасывает `NullPointerException`, если объект равен `null`.
    *   `toString(Object o)` — возвращает строковое представление объекта или `"null"`.
    *   `compare(T a, T b, Comparator<? super T> c)` — сравнение объектов с использованием компаратора.
*   Используется для безопасной и удобной работы с объектами, особенно при реализации методов `equals()`, `hashCode()` и `toString()`[6].

Таким образом, `Collections` и `Arrays` предоставляют мощные и удобные методы для работы с коллекциями и массивами, обеспечивая сортировку, поиск, сравнение, копирование и другие операции, а `Objects` помогает безопасно управлять объектами и их сравнениями в Java[1][2][3][6].


**Вопрос 13**

В Java потоки ввода-вывода делятся на два основных типа: байтовые и символьные.

## Байтовые потоки
* Работают с данными в виде байтов (8 бит).
* Основные базовые абстрактные классы:
  * `InputStream` — для чтения байтов.
  * `OutputStream` — для записи байтов.
* Популярные потомки:
  * `FileInputStream` и `FileOutputStream` — для работы с файлами.
  * `ByteArrayInputStream` и `ByteArrayOutputStream` — для работы с массивами байтов в памяти.
  * `BufferedInputStream` и `BufferedOutputStream` — для буферизации байтового ввода-вывода.
* Методы:
  * `read()` — чтение байта или массива байтов.
  * `write()` — запись байта или массива байтов.
  * `close()` — закрытие потока.
* Байтовые потоки удобны для работы с бинарными данными (например, изображениями, аудио).

## Символьные потоки
* Работают с символами Unicode (16 бит).
* Основные базовые абстрактные классы:
  * `Reader` — для чтения символов.
  * `Writer` — для записи символов.
* Популярные потомки:
  * `FileReader` и `FileWriter` — для работы с файлами символов.
  * `BufferedReader` и `BufferedWriter` — для буферизации символьного ввода-вывода.
  * `CharArrayReader` и `CharArrayWriter` — для работы с массивами символов.
  * `PrintWriter` — для удобного вывода с методами `print()` и `println()`.
* Методы:
  * `read()` — чтение символа или массива символов.
  * `write()` — запись символа или массива символов.
  * `close()` — закрытие потока.
* Символьные потоки удобны для работы с текстовыми данными с учетом кодировок.

## Мосты между байтовыми и символьными потоками
* `InputStreamReader` — преобразует байтовый поток `InputStream` в символьный `Reader`, учитывая кодировку.
* `OutputStreamWriter` — преобразует символьный поток `Writer` в байтовый `OutputStream`.
* Позволяют работать с текстом в нужной кодировке (например, UTF-8, Cp1251).

## Итог
| Тип потока       | Базовый класс     | Основные потомки                   | Назначение                      |
|------------------|-------------------|----------------------------------|--------------------------------|
| Байтовый поток   | InputStream / OutputStream | FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream | Работа с бинарными данными      |
| Символьный поток | Reader / Writer   | FileReader, FileWriter, BufferedReader, BufferedWriter, PrintWriter | Работа с текстовыми данными (Unicode) |

Таким образом, байтовые потоки оперируют с сырыми байтами, а символьные — с символами Unicode, обеспечивая удобство работы с текстом и кодировками. Для преобразования между ними используются классы-мосты `InputStreamReader` и `OutputStreamWriter`[1][2][3][5][6][7][8].


**Вопрос 14**

В Java потоки-фильтры — это специальные классы, которые принимают в конструкторе другой поток и оборачивают его, добавляя дополнительную функциональность, например, буферизацию, преобразование или форматирование данных[2][6].

## Потоки-фильтры

* Потоки-фильтры принимают в конструкторе исходный поток и преобразуют или дополняют его поведение.
* Они позволяют строить цепочки потоков, комбинируя разные операции ввода-вывода.
* Пример: буферизация, преобразование байтов в символы, форматированный вывод.

## Класс BufferedReader

* Является потомком `Reader` и представляет собой поток-фильтр для символьного ввода.
* Буферизует данные, считывая сразу большой блок символов из базового потока, что повышает производительность при последовательном чтении.
* Не преобразует байты в символы — для этого нужен `InputStreamReader`.
* Позволяет читать данные построчно с помощью метода `readLine()`.
* Обычно создаётся как обёртка над `InputStreamReader` или другим `Reader`, например:
  ```java
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  ```
* При закрытии `BufferedReader` автоматически закрывается и вложенный поток[3][7][8].

## Класс InputStreamReader

* Является мостом между байтовыми и символьными потоками.
* Наследуется от `Reader`.
* Преобразует байты из `InputStream` в символы с учётом заданной кодировки (по умолчанию — системная).
* Используется для чтения текстовых данных из байтовых источников, например, из консоли или файла.
* Пример использования:
  ```java
  InputStreamReader isr = new InputStreamReader(System.in, "UTF-8");
  ```
* Часто используется в связке с `BufferedReader` для эффективного и удобного чтения текста[2][7][8].

## Класс PrintStream

* Реализует байтовый поток вывода (`OutputStream`).
* Предназначен для вывода данных на консоль, в файл или другой байтовый источник.
* Поддерживает буферизацию и автоматический сброс буфера (например, при вызове `println()`).
* Позволяет выводить данные в текстовом формате с удобными методами `print()` и `println()`.
* В Java стандартный поток вывода `System.out` — это объект класса `PrintStream`.
* Может использоваться для вывода с заданной кодировкой через обёртки, например, `OutputStreamWriter`.
* Конструктор с параметром `autoFlush` позволяет автоматически сбрасывать буфер после вызова методов вывода строк[2][7].

---

Таким образом, `InputStreamReader` преобразует байты в символы, `BufferedReader` буферизует символы и предоставляет удобное чтение строк, а `PrintStream` обеспечивает удобный и буферизованный вывод байтов, часто используемый для вывода на консоль. Все они являются важными элементами цепочек потоков-фильтров в Java.


**Вопрос 15**

В Java стандартный ввод и вывод представлены тремя предопределёнными потоками в классе `System`:

- **`System.in`** — стандартный поток ввода, по умолчанию связанный с клавиатурой. Это объект типа `InputStream`, который читает байты с консоли. Для удобного чтения текстовых данных его обычно оборачивают в классы, например, `Scanner` или `BufferedReader` через `InputStreamReader`[1][2][4][6].

- **`System.out`** — стандартный поток вывода, по умолчанию связанный с консолью. Это объект класса `PrintStream`, который позволяет выводить данные в текстовом формате с помощью методов `print()`, `println()` и др. Можно перенаправлять вывод в файлы или другие потоки[2][4][5].

- **`System.err`** — стандартный поток вывода ошибок, также связанный с консолью. Используется для вывода сообщений об ошибках и предупреждениях. В отличие от `System.out`, поток `System.err` обычно не буферизуется, поэтому вывод ошибок отображается сразу[2][3].

---

### Класс Scanner

* Предназначен для удобного чтения данных из различных источников, включая стандартный ввод (`System.in`).
* Поддерживает чтение различных типов данных: строки (`nextLine()`), целые числа (`nextInt()`), числа с плавающей точкой, логические значения и др.
* Для работы со стандартным вводом создаётся так:
  ```java
  Scanner scanner = new Scanner(System.in);
  String line = scanner.nextLine();
  int number = scanner.nextInt();
  ```
* Позволяет удобно парсить входные данные по пробелам, переходам строк и другим разделителям[1][6].

---

Таким образом, для ввода с клавиатуры используется `System.in`, который часто оборачивают в `Scanner` для удобного чтения, а для вывода на консоль — `System.out` (обычно `PrintStream`), а для ошибок — `System.err`. Эти потоки являются стандартными и доступны через статические поля класса `System`.


**Вопрос 16**

В Java **сериализация объектов** — это процесс преобразования объекта в последовательность байтов для сохранения в файл, передачи по сети или кэширования, с возможностью последующего восстановления объекта (десериализации).

## Интерфейс Serializable

* `Serializable` — это **маркерный интерфейс**, который не содержит методов и служит для обозначения класса как сериализуемого[2][4].
* Чтобы объект можно было сериализовать, класс должен реализовать этот интерфейс.
* Все поля объекта также должны быть сериализуемыми (примитивные типы сериализуются по умолчанию).
* Если класс наследуется от несериализуемого суперкласса, у того должен быть конструктор без аргументов[2].
* Для сериализации используется класс `ObjectOutputStream`, для десериализации — `ObjectInputStream`[3][5].

## Модификатор transient

* Поля, объявленные с модификатором `transient`, **исключаются из процесса сериализации**[1][2][4].
* Это полезно для полей, которые не должны сохраняться, например, временные данные, ссылки на ресурсы, которые нельзя или не нужно сериализовать.
* При десериализации такие поля получают значение по умолчанию (например, `null` для объектов, `0` для чисел).
* При необходимости можно самостоятельно сериализовать и десериализовать `transient` поля, реализовав методы `writeObject(ObjectOutputStream out)` и `readObject(ObjectInputStream in)`[2][4].

---

### Пример использования Serializable и transient

```java
import java.io.Serializable;

public class Target implements Serializable {
    private int intField;
    private String strField;
    private transient int transientField; // не сериализуется

    public Target(int i, String s, int trn) {
        this.intField = i;
        this.strField = s;
        this.transientField = trn;
    }

    @Override
    public String toString() {
        return "Target{" +
               "intField=" + intField +
               ", strField='" + strField + '\'' +
               ", transientField=" + transientField +
               '}';
    }
}
```

При сериализации объекта `Target` поле `transientField` не будет сохранено, и после десериализации оно будет иметь значение по умолчанию (0)[2][4].

---

Таким образом, интерфейс `Serializable` позволяет отмечать классы для сериализации, а модификатор `transient` исключает отдельные поля из этого процесса, что даёт гибкость при сохранении состояния объектов.



**Вопрос 17**

В Java для работы с файлами используются несколько ключевых классов и интерфейсов, которые обеспечивают удобное и современное управление файловой системой.

## Интерфейс Path

* `Path` — это интерфейс из пакета `java.nio.file`, который является современным и более удобным аналогом класса `File`.
* Представляет путь к файлу или директории как последовательность элементов (папок и имени файла).
* Методы `Path` возвращают объекты типа `Path`, что упрощает работу с путями и исключает неоднозначность, свойственную классу `File` (где методы могли возвращать разные типы — строки, boolean или объекты `File`).
* Позволяет легко получать имя файла (`getFileName()`), родительский путь (`getParent()`), количество элементов пути (`getNameCount()`), подпути (`subpath()`), преобразовывать путь в строку (`toString()`) и др.
* Пример создания пути:
  ```java
  Path p1 = Paths.get("/foo/bar");
  Path p2 = Paths.get(URI.create("file:///foo/bar/Main.java"));
  ```

## Класс Paths

* Утилитный класс с статическими методами для создания объектов `Path`.
* Основные методы:
  * `Paths.get(String first, String... more)` — создает объект `Path` из одного или нескольких компонентов пути.
  * `Paths.get(URI uri)` — создает `Path` из URI.
* Используется для получения объекта `Path` для дальнейших операций.

## Класс File

* Более старый класс из пакета `java.io`, который работает с файлами и директориями.
* Позволяет получать информацию о файле (путь, права доступа, дата создания), создавать и удалять файлы и каталоги.
* Методы возвращают разные типы (например, `String`, `boolean`, `File`), что усложняет использование.
* Пример создания файла:
  ```java
  File file = new File("example.txt");
  ```
* Поддерживает навигацию по файловой системе, но менее удобен и функционален по сравнению с `Path` и `Files`.

## Класс Files

* Утилитный класс из пакета `java.nio.file`, содержащий множество статических методов для работы с файлами и директориями.
* Работает с объектами `Path`.
* Основные методы:
  * `createFile(Path path)` — создает новый файл.
  * `createDirectory(Path path)` — создает новую директорию.
  * `delete(Path path)` — удаляет файл или директорию.
  * `copy(Path source, Path target)` — копирует файл.
  * `move(Path source, Path target, CopyOption... options)` — перемещает или переименовывает файл.
  * `exists(Path path)` — проверяет существование файла или директории.
  * `isDirectory(Path path)` — проверяет, является ли путь директорией.
  * `size(Path path)` — возвращает размер файла.
* Обеспечивает более современный и удобный API для работы с файловой системой по сравнению с классом `File`.

---

### Итоговое сравнение

| Класс / Интерфейс | Назначение                              | Особенности и примеры использования                          |
|-------------------|---------------------------------------|-------------------------------------------------------------|
| `Path`            | Интерфейс для представления пути      | Современный способ работы с путями, возвращает объекты Path |
| `Paths`           | Утилитный класс для создания Path     | Статические методы `get()` для создания объектов Path       |
| `File`            | Класс для работы с файлами и каталогами | Старый класс, методы возвращают разные типы, менее удобен   |
| `Files`           | Утилитный класс с методами для файлов | Статические методы для создания, удаления, копирования и др.|

---

Таким образом, современный подход в Java — использовать интерфейс `Path` для представления путей, класс `Paths` для их создания и класс `Files` для выполнения операций с файлами и директориями, что обеспечивает более чистый и удобный API по сравнению с классом `File`[1][2][4][5][6][7].



**Вопрос 18**

Новый пакет ввода-вывода в Java называется NIO (New Input/Output) и предоставляет более эффективный и гибкий механизм работы с данными по сравнению с классическими потоками. Основными элементами этого пакета являются буферы и каналы.

## Буферы и каналы в Java NIO

- **Буферы (Buffers)** — это контейнеры для данных одного примитивного типа (чаще всего байтов). Они используются для временного хранения данных при операциях ввода-вывода. Буферы бывают двух типов: direct (прямой доступ к памяти, используемой устройством) и non-direct (память синхронизируется с памятью устройства)[8].

- **Каналы (Channels)** — это объекты, которые обеспечивают двунаправленный доступ к источнику или приемнику данных. Каналы могут читать и писать данные в буферы. Основные типы каналов в Java NIO:
  - FileChannel — для работы с файлами,
  - DatagramChannel — для передачи датаграмм,
  - SocketChannel — для сетевого ввода-вывода,
  - ServerSocketChannel — для установки сетевых соединений[8][9].

Каналы являются более эффективной альтернативой потокам, так как позволяют работать с данными напрямую через буферы и поддерживают операции позиционирования, блокировки и передачи данных между каналами.

## Класс FileChannel

`FileChannel` — это канал для чтения, записи, отображения и управления файлами. Он реализует интерфейс `SeekableByteChannel`, что позволяет перемещаться по файлу, читать и записывать данные в произвольных позициях[2][5].

### Основные возможности FileChannel:

- Чтение и запись данных в файл с возможностью указания позиции,
- Получение и установка текущей позиции в файле,
- Получение размера файла,
- Отображение части файла в память (memory-mapped files) через метод `map()`,
- Передача данных напрямую между каналами (например, для копирования файлов),
- Блокировка частей файла для синхронизации доступа из разных потоков,
- Принудительная запись данных на диск для предотвращения потери данных[5][6].

### Работа с FileChannel

Для открытия канала используется, например, класс `RandomAccessFile` или потоки `FileInputStream`/`FileOutputStream` с вызовом метода `getChannel()`:

```java
RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
FileChannel channel = file.getChannel();
```

Чтение данных осуществляется через буфер `ByteBuffer`:

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);
```

Позиция чтения/записи может быть получена и изменена:

```java
long position = channel.position();
channel.position(5);
```

Размер файла можно получить методом `size()`:

```java
long size = channel.size();
```

### Преимущества FileChannel

- Возможность позиционированного доступа к файлу,
- Эффективная работа с большими файлами через memory-mapped buffers,
- Высокая производительность при передаче данных между каналами,
- Поддержка блокировок для многопоточного доступа[5].

Таким образом, новый пакет ввода-вывода Java NIO с классом `FileChannel` и буферами предоставляет мощный и гибкий инструмент для эффективной работы с файлами и другими источниками данных, превосходящий по возможностям классические потоки ввода-вывода[1][5][6][8].

**Вопрос 19**

Взаимодействие Java с базами данных осуществляется через **JDBC (Java Database Connectivity)**, представляющий собой платформенно-независимый стандарт, позволяющий Java-приложениям взаимодействовать с различными СУБД[1][3][5][6]. JDBC API предоставляет набор интерфейсов и классов в пакете `java.sql`, позволяющих отправлять SQL-запросы в базу данных и обрабатывать результаты[1][5][6].

### Основные элементы JDBC:

1.  **JDBC API**: Предоставляет интерфейс между Java-приложением и JDBC-менеджером[3]. Содержит интерфейсы для разработчиков приложений и для разработчиков драйверов[1].

2.  **JDBC-драйверы**: Реализации JDBC API для конкретных баз данных, обеспечивающие связь между JDBC-менеджером и драйвером базы данных[3][6]. Драйверы позволяют получать соединение с базой данных по специально описанному URL[1][7][8]. Существуют различные типы драйверов JDBC[6][9]:
    *   **Тип 1 (JDBC-ODBC bridge)**: Использует ODBC драйвер, установленный в системе (устаревший)[6][9].
    *   **Тип 2 (Native API)**: Использует клиентские библиотеки базы данных (платформозависимый)[6][9].
    *   **Тип 3 (Net-protocol driver)**: Использует промежуточный сервер приложений для преобразования запросов[6][9].
    *   **Тип 4 (Thin driver)**: Непосредственно преобразует вызовы JDBC в протокол базы данных[6][9].

3.  **DriverManager**: Класс, управляющий JDBC-драйверами[3]. Он загружает драйверы и предоставляет соединение с базой данных[1][7][8].

4.  **Connection**: Интерфейс, представляющий соединение с базой данных[3]. Через объект `Connection` происходит взаимодействие с СУБД[3].

5.  **Statement**: Интерфейс, используемый для выполнения SQL-запросов[3][5]. Существуют различные типы `Statement`, такие как `PreparedStatement` (для параметризованных запросов) и `CallableStatement` (для вызова хранимых процедур)[3][5].

6.  **ResultSet**: Интерфейс, представляющий результирующий набор данных, полученный из базы данных после выполнения запроса[3].

### Процесс взаимодействия с базой данных через JDBC:

1.  **Загрузка драйвера**: Драйвер загружается в память[7][8].
2.  **Установка соединения**: Устанавливается соединение с базой данных с использованием URL, имени пользователя и пароля[3][7][8].
3.  **Создание Statement**: Создается объект `Statement` для выполнения SQL-запросов[3][8].
4.  **Выполнение запроса**: SQL-запрос выполняется с помощью методов `executeQuery()` (для запросов `SELECT`) или `executeUpdate()` (для запросов `INSERT`, `UPDATE`, `DELETE`)[5].
5.  **Обработка результатов**: Результаты запроса обрабатываются через объект `ResultSet`[5].
6.  **Закрытие соединения**: Все соединения закрываются[3][8].

JDBC обеспечивает независимость от конкретной СУБД, позволяя Java-приложениям взаимодействовать с различными базами данных при наличии соответствующего драйвера[5]. The user is interested in Java and object-oriented programming [10][11]. They are also learning about Java's collections and input/output streams, which are relevant to working with databases [12][13].

**Вопрос 20**

## Создание соединения с базой данных в Java через JDBC

### Класс DriverManager

`DriverManager` — это класс-утилита, управляющий списком зарегистрированных JDBC-драйверов и устанавливающий соединения с базой данных. Он выбирает подходящий драйвер по URL-адресу подключения и предоставляет объект интерфейса `Connection`.

Основной метод для создания соединения:

```java
Connection connection = DriverManager.getConnection(String url, String user, String password);
```

- `url` — строка подключения в формате `jdbc:subprotocol:subname`, например, для MySQL:  
  `"jdbc:mysql://localhost/название_базы"`
- `user` и `password` — логин и пароль для доступа к базе.

Перед созданием соединения рекомендуется загрузить драйвер:

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

Это регистрирует драйвер в `DriverManager` (в новых версиях Java часто не требуется явно).

---

### Интерфейс Connection

`Connection` — интерфейс, представляющий активное соединение с базой данных. Через объект `Connection` выполняются SQL-запросы, создаются объекты `Statement`, управляются транзакции и закрывается соединение.

Основные методы `Connection`:

- `createStatement()` — создание объекта для выполнения SQL-запросов,
- `prepareStatement(String sql)` — создание подготовленного запроса с параметрами,
- `commit()` и `rollback()` — управление транзакциями,
- `close()` — закрытие соединения и освобождение ресурсов,
- `setAutoCommit(boolean autoCommit)` — включение/отключение автокоммита.

---

### Пример создания соединения и создания базы данных

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class CreateDBJdbc {
    static final String DATABASE_URL = "jdbc:mysql://localhost/";
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String USER = "ваш_пользователь";
    static final String PASSWORD = "ваш_пароль";

    public static void main(String[] args) {
        Connection connection = null;
        Statement statement = null;

        try {
            // Регистрация драйвера
            Class.forName(JDBC_DRIVER);
            System.out.println("Connecting to DB...");
            // Создание соединения
            connection = DriverManager.getConnection(DATABASE_URL, USER, PASSWORD);

            // Создание объекта Statement для выполнения SQL
            statement = connection.createStatement();
            String sql = "CREATE DATABASE PROSELYTE_JDBC_DB";
            statement.executeUpdate(sql);
            System.out.println("Database successfully created...");
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            // Закрытие ресурсов
            try {
                if (statement != null) statement.close();
                if (connection != null) connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

### Ключевые моменты

- `DriverManager` управляет драйверами и создаёт соединение с базой данных.
- Метод `getConnection()` возвращает объект `Connection`.
- `Connection` — основной интерфейс для взаимодействия с базой: выполнение запросов, управление транзакциями, закрытие соединения.
- Для подключения требуется корректно сформированный URL, имя пользователя и пароль.
- После работы соединение обязательно закрывается для освобождения ресурсов.

---

Таким образом, создание соединения с базой данных в Java через JDBC сводится к загрузке драйвера, вызову `DriverManager.getConnection()` и работе с полученным объектом `Connection` для выполнения SQL-запросов и управления транзакциями[1][2][5][6].

**Вопрос 21**

## Создание запросов в JDBC: интерфейсы Statement, PreparedStatement и CallableStatement

### 1. Интерфейс **Statement**

- Используется для выполнения простых SQL-запросов без параметров.
- Подходит для одноразового выполнения SQL, например, DDL-команд (`CREATE`, `DROP`).
- Методы:
  - `execute(String sql)` — выполнение любого SQL-запроса,
  - `executeQuery(String sql)` — выполнение запроса `SELECT`, возвращает `ResultSet`,
  - `executeUpdate(String sql)` — выполнение запросов `INSERT`, `UPDATE`, `DELETE`, возвращает количество изменённых строк,
  - `executeBatch()` — выполнение пакета запросов.
- Не поддерживает параметризацию, что повышает риск SQL-инъекций при динамическом формировании запросов.

### 2. Интерфейс **PreparedStatement**

- Наследует `Statement`.
- Представляет предкомпилированный SQL-запрос, который может содержать параметры-заполнители `?`.
- Позволяет многократно выполнять один и тот же запрос с разными параметрами, что повышает производительность.
- Параметры задаются через методы `setInt()`, `setString()`, `setDate()` и др.
- Обеспечивает защиту от SQL-инъекций, так как параметры экранируются драйвером.
- Создаётся через `Connection.prepareStatement(sql)`.
- Пример:

```java
String sql = "UPDATE employees SET salary = ? WHERE id = ?";
PreparedStatement pstmt = connection.prepareStatement(sql);
pstmt.setDouble(1, 5000.0);
pstmt.setInt(2, 101);
pstmt.executeUpdate();
```

### 3. Интерфейс **CallableStatement**

- Наследует `PreparedStatement`.
- Предназначен для вызова хранимых процедур в базе данных.
- Позволяет работать с тремя типами параметров:
  - `IN` — входные,
  - `OUT` — выходные,
  - `INOUT` — входные/выходные.
- Позволяет регистрировать выходные параметры и получать их значения после выполнения процедуры.
- Создаётся через `Connection.prepareCall(sql)`, где `sql` — вызов процедуры с параметрами-заполнителями.
- Пример вызова хранимой процедуры:

```java
CallableStatement cstmt = connection.prepareCall("{CALL ADD(?, ?, ?)}");
cstmt.setInt(1, 123); // IN параметр
cstmt.setInt(2, 234); // IN параметр
cstmt.registerOutParameter(3, Types.INTEGER); // OUT параметр
cstmt.execute();
int sum = cstmt.getInt(3); // получение результата
```

---

### Иерархия и особенности

| Интерфейс          | Назначение                         | Параметры           | Особенности                                  |
|--------------------|----------------------------------|---------------------|----------------------------------------------|
| Statement          | Выполнение простых SQL-запросов  | Нет                 | Не поддерживает параметры, простой в использовании |
| PreparedStatement  | Предкомпилированные запросы с параметрами | Только входные (IN)  | Повышенная производительность, защита от SQL-инъекций |
| CallableStatement  | Вызов хранимых процедур          | IN, OUT, INOUT      | Поддержка выходных параметров, сложные процедуры |

---

### Итоги

- Для простых одноразовых запросов подходит `Statement`.
- Для многократного выполнения параметризованных запросов — `PreparedStatement`.
- Для вызова хранимых процедур с возможностью работы с выходными параметрами — `CallableStatement`.

Все три интерфейса создаются через методы объекта `Connection`:

```java
Statement stmt = connection.createStatement();
PreparedStatement pstmt = connection.prepareStatement(sql);
CallableStatement cstmt = connection.prepareCall(sql);
```

Это позволяет гибко и эффективно работать с базой данных в зависимости от задач[1][2][3][4][5][6][8].

**Вопрос 22**

## Выполнение запросов в JDBC: методы execute, executeQuery и executeUpdate

Для выполнения SQL-запросов через объект `Statement` в JDBC используются три основных метода, которые различаются по типу выполняемых команд и возвращаемым результатам.

---

### 1. Метод **executeQuery(String sql)**

- Предназначен для выполнения SQL-запросов типа `SELECT`, которые возвращают данные.
- Возвращает объект `ResultSet`, содержащий результат выборки.
- Пример использования:

```java
ResultSet rs = statement.executeQuery("SELECT * FROM employees");
while (rs.next()) {
    String name = rs.getString("name");
    int salary = rs.getInt("salary");
    // обработка данных
}
```

---

### 2. Метод **executeUpdate(String sql)**

- Используется для выполнения SQL-команд, изменяющих данные или структуру базы:
  - `INSERT`, `UPDATE`, `DELETE`,
  - DDL-команды: `CREATE TABLE`, `DROP TABLE` и др.
- Возвращает `int` — количество строк, затронутых операцией, или 0, если команда не изменяет строки (например, создание таблицы).
- Пример:

```java
int rowsAffected = statement.executeUpdate("UPDATE employees SET salary = salary + 1000");
System.out.println("Обновлено строк: " + rowsAffected);
```

---

### 3. Метод **execute(String sql)**

- Универсальный метод для выполнения любых SQL-команд.
- Возвращает `boolean`:
  - `true` — если результатом является набор строк (например, `SELECT`),
  - `false` — если команда не возвращает набор строк (например, `INSERT`, `UPDATE`).
- После вызова метода для получения результата используют:
  - `getResultSet()` — для получения `ResultSet` при `true`,
  - `getUpdateCount()` — для получения количества затронутых строк при `false`.
- Пример:

```java
boolean hasResultSet = statement.execute("SELECT * FROM employees");
if (hasResultSet) {
    ResultSet rs = statement.getResultSet();
    // обработка данных
} else {
    int updateCount = statement.getUpdateCount();
    System.out.println("Изменено строк: " + updateCount);
}
```

---

### Итоговое сравнение

| Метод           | Для каких запросов           | Возвращаемое значение       | Особенности                              |
|-----------------|-----------------------------|-----------------------------|-----------------------------------------|
| `executeQuery`  | Только SELECT               | `ResultSet`                 | Удобен для выборки данных                |
| `executeUpdate` | INSERT, UPDATE, DELETE, DDL | `int` (число изменённых строк) | Для изменения данных и структуры БД     |
| `execute`       | Любые SQL-команды           | `boolean`                   | Универсальный, требует дополнительной обработки результата |

---

Таким образом, выбор метода зависит от типа SQL-запроса: для выборки данных — `executeQuery`, для обновления — `executeUpdate`, а если тип запроса заранее неизвестен — универсальный `execute`[1][2][3][5].

**Вопрос 23**

## Обработка результатов запроса в JDBC: интерфейс ResultSet и получение значений

### Интерфейс ResultSet

`ResultSet` представляет собой таблицу данных, полученную в результате выполнения SQL-запроса (обычно `SELECT`). Он обеспечивает построчный доступ к этим данным и позволяет перемещаться по строкам результата.

- **Курсор** — внутренний указатель, который указывает на текущую строку в наборе результатов. Изначально курсор находится «до первой строки» (позиция перед первой записью).
- Для перехода к следующей строке используется метод `next()`, который возвращает `true`, если следующая строка существует, и `false` при достижении конца набора.

### Основные методы перемещения по ResultSet

- `boolean next()` — перейти к следующей строке,
- `boolean previous()` — перейти к предыдущей (если ResultSet скроллируемый),
- `boolean isBeforeFirst()`, `isAfterLast()`, `isFirst()`, `isLast()` — проверить позицию курсора,
- `int getRow()` — получить номер текущей строки (начинается с 1).

### Получение значений из ResultSet

Для извлечения данных из текущей строки используются методы `getXXX()`, где `XXX` — тип данных:

- `getString(columnIndex или columnName)` — получить строку,
- `getInt(columnIndex или columnName)` — получить целое число,
- `getDouble()`, `getDate()`, `getBoolean()` и др. — для других типов.

Индексация колонок начинается с 1. Можно обращаться как по индексу, так и по имени столбца.

Пример:

```java
while (rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    double salary = rs.getDouble("salary");
    System.out.printf("ID: %d, Name: %s, Salary: %.2f%n", id, name, salary);
}
```

### Обработка NULL-значений

Если в базе поле может быть `NULL`, после вызова `getXXX()` рекомендуется проверить методом `wasNull()`, чтобы отличить `NULL` от значений по умолчанию (например, 0 для чисел):

```java
int value = rs.getInt("some_column");
if (rs.wasNull()) {
    // обработка NULL
}
```

### Пример полного использования ResultSet

```java
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT id, name, salary FROM employees");

while (rs.next()) {
    int id = rs.getInt(1); // или rs.getInt("id")
    String name = rs.getString("name");
    double salary = rs.getDouble("salary");
    System.out.println(id + " | " + name + " | " + salary);
}

rs.close();
stmt.close();
```

---

### Итоги

- `ResultSet` — это результат выполнения запроса, предоставляющий построчный доступ к данным.
- Для перемещения по строкам используется метод `next()`.
- Для получения значений из столбцов — методы `getInt()`, `getString()`, `getDouble()` и др.
- Можно обращаться к столбцам по имени или индексу.
- Для проверки наличия `NULL` используется метод `wasNull()`.

Такой подход позволяет эффективно и удобно обрабатывать результаты запросов в JDBC[1][2][3][4][5].

**Вопрос 24**

## Многопоточность в Java: класс Thread, интерфейс Runnable и состояния потока

### Класс Thread

- Представляет поток исполнения — отдельный легковесный процесс внутри программы.
- Для создания потока можно унаследовать класс `Thread` и переопределить метод `run()`, в котором описывается код, выполняемый в отдельном потоке.
- Запуск потока осуществляется вызовом метода `start()`, который создаёт новый поток и вызывает `run()` асинхронно.
- Пример:

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Поток запущен");
    }
}

MyThread t = new MyThread();
t.start();
```

### Интерфейс Runnable

- Определяет единственный метод `run()`.
- Позволяет реализовать задачу, которую можно выполнить в отдельном потоке.
- Для запуска создаётся объект `Thread`, которому в конструктор передаётся реализация `Runnable`.
- Такой подход более гибкий, так как класс может наследовать другой класс и одновременно реализовывать `Runnable`.
- Пример:

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Поток через Runnable");
    }
}

Thread t = new Thread(new MyRunnable());
t.start();
```

### Состояния потока в Java

Основные состояния потока (по спецификации JVM):

- **NEW** — поток создан, но метод `start()` ещё не вызван.
- **RUNNABLE** — поток готов к выполнению или выполняется. После вызова `start()` поток переходит в это состояние, но фактическое выполнение зависит от планировщика ОС[1].
- **BLOCKED** — поток заблокирован, ожидает монитор (например, при входе в synchronized-блок).
- **WAITING** — поток ожидает уведомления без ограничения по времени (методы `wait()`, `join()` без таймаута).
- **TIMED_WAITING** — поток ожидает с ограничением по времени (например, `sleep()`, `join(timeout)`).
- **TERMINATED (DEAD)** — поток завершил выполнение метода `run()` и больше не активен.

### Ключевые моменты

- Для запуска нового потока всегда вызывается `start()`, а не `run()` напрямую. Вызов `run()` не создаёт новый поток, а выполняется в текущем.
- Планировщик потоков JVM и ОС решают, когда и какой поток выполняется.
- Поток после завершения нельзя запустить повторно.
- Использование `Runnable` предпочтительнее, если класс уже наследует другой класс, или для разделения задачи и управления потоком[2][4][6][8].

---

Таким образом, многопоточность в Java реализуется через класс `Thread` и интерфейс `Runnable`. Поток создаётся, запускается и переходит через несколько состояний от создания до завершения, что позволяет выполнять несколько задач параллельно.

**Вопрос 25**

## Гонки, синхронизация потоков, мониторы и модификатор synchronized в Java

### Гонки (Race Conditions)

Состояние гонки возникает, когда несколько потоков одновременно пытаются получить доступ к общим данным или ресурсам, при этом как минимум один поток пытается изменить эти данные[1][2][3][5]. Результат выполнения программы зависит от непредсказуемого порядка выполнения потоков[4][5]. Это может привести к непредсказуемым ошибкам, которые сложно воспроизвести и отладить[5][8].

Пример гонки: два потока одновременно увеличивают значение одной и той же переменной.  Каждый поток выполняет три операции: чтение значения из памяти, увеличение значения и запись обратно в память. Если потоки выполняют эти операции попеременно, конечное значение переменной может быть неверным[5].

### Синхронизация потоков

Синхронизация потоков — это механизм, обеспечивающий упорядоченный доступ к общим ресурсам, предотвращая состояния гонки[2][5].  В Java для синхронизации используются мониторы и ключевое слово `synchronized`.

### Мониторы

Каждый объект в Java имеет связанный с ним монитор, который можно использовать для управления доступом к synchronized-блокам и методам.  Монитор позволяет только одному потоку в каждый момент времени выполнять код, защищённый этим монитором.

### Модификатор `synchronized`

Модификатор `synchronized` используется для синхронизации доступа к блокам кода или методам. Он гарантирует, что только один поток может выполнять synchronized-код для данного объекта в один момент времени.

1.  **synchronized-метод**:

    ```java
    public synchronized void increment() {
        count++;
    }
    ```

    Когда поток вызывает `increment()`, он должен получить блокировку монитора объекта, на котором вызывается метод.  Другие потоки, пытающиеся вызвать этот или любой другой `synchronized` метод этого же объекта, будут заблокированы до тех пор, пока первый поток не освободит монитор.
2.  **synchronized-блок**:

    ```java
    public void someMethod() {
        synchronized (this) {
            // Критическая секция
            // Код, требующий синхронизации
        }
    }
    ```

    В этом случае, поток должен получить блокировку монитора объекта `this`, прежде чем выполнить код внутри `synchronized` блока.
    Можно синхронизироваться по любому объекту, например:

    ```java
    private Object lock = new Object();
    public void someMethod() {
        synchronized (lock) {
            // Критическая секция
        }
    }
    ```
    Это позволяет более точно контролировать область синхронизации.

### Предотвращение гонок

Для предотвращения состояний гонки необходимо правильно спроектировать многопоточную систему и использовать механизмы синхронизации[6]. Важно определить критические секции кода, где происходит доступ к общим ресурсам, и защитить их с помощью `synchronized` или других средств синхронизации.

Дополнительные способы предотвращения гонок:

*   Использование неизменяемых объектов (immutable objects): Если объекты не могут быть изменены после создания, то не требуется синхронизация доступа к ним.
*   Использование потокобезопасных коллекций: Классы из пакета `java.util.concurrent` (например, `ConcurrentHashMap`, `CopyOnWriteArrayList`) обеспечивают потокобезопасный доступ к коллекциям.
*   Минимизация области синхронизации: Чем меньше код, выполняемый под блокировкой, тем меньше вероятность возникновения проблем с производительностью.
*   Использование `volatile` для переменных:  Ключевое слово `volatile` гарантирует, что изменения переменной будут видны всем потокам немедленно.

### Пример

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Count: " + counter.getCount()); // Ожидаем 2000
    }
}
```

В этом примере класс `Counter` использует `synchronized` метод `increment()` для предотвращения состояний гонки при увеличении переменной `count`.  Без `synchronized` результат мог бы быть меньше 2000 из-за одновременного доступа к переменной из разных потоков.

Ранее вы интересовались Java и объектно-ориентированным программированием, а также изучали потоки ввода-вывода [9], коллекции [10] и подключение к базам данных [11][12][13]. Многопоточность тесно связана с этими темами, поскольку позволяет эффективно использовать ресурсы и создавать более производительные приложения. [9][10][11][12][13]









