**Вопрос 1**

Параметризованные типы, также известные как обобщения, позволяют объявлять классы, интерфейсы и методы, в которых тип данных указывается в виде параметра[7][8]. Использование параметризованных типов обеспечивает типовую безопасность[1][10].

**Создание параметризованных классов**
1.  **Объявление:** Параметризованный класс объявляется так же, как и обычный класс, но с добавлением раздела параметров типа после имени класса[6]. Раздел параметров типа состоит из одного или нескольких параметров типа, разделенных запятыми[6].
    ```java
    class ИмяКласса<T> {
        // ...
    }
    ```
2.  **Параметры типа:** В угловых скобках `<>` указывается имя параметра типа, которое используется в качестве заполнителя для реального типа, передаваемого классу при создании экземпляра[8].
3.  **Использование:** Внутри класса параметр типа может использоваться для объявления переменных, параметров методов и возвращаемых типов[7].
    ```java
    class Generics<T> {
        T ob;
        Generics(T o) {
            ob = o;
        }
        T getObject() {
            return ob;
        }
    }
    ```
4.  **Инстанцирование:** При создании экземпляра параметризованного класса необходимо указать конкретный тип данных, который будет использоваться[7].
    ```java
    Generics<Integer> iObject = new Generics<>(777);
    Generics<String> strOb = new Generics<>("Обобщенный текст");
    ```
5.  **Примеры параметризованных классов**:
    *   Очередь (Queue): параметризованная очередь, работающая с любыми типами данных[9].
    *   Хранилище (Storage): универсальное хранилище элементов любого типа[9].
    *   Пара (Pair): способ хранения двух связанных переменных разных типов[9].

Параметризованные классы могут быть частью иерархии классов, выступая в качестве суперкласса или подкласса[7]. В параметризованной иерархии любые аргументы типов, необходимые параметризованному суперклассу, должны передаваться всеми подклассами по иерархии вверх[7].

**Вопрос 2**

Параметризованные методы позволяют использовать один и тот же метод с разными типами данных[3][5]. Ограничения типов позволяют указать, какие типы данных могут быть использованы в параметризованных методах[5]. Вы интересуетесь объектно-ориентированным программированием, особенно параметризованными классами и ограничениями типов[9].

**Работа с параметризованными методами**

1.  **Объявление:** Параметризованные методы объявляются с использованием раздела параметров типа перед типом возвращаемого значения[5].
    ```java
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
    ```
2.  **Вызов:** При вызове параметризованного метода тип можно указать явно или позволить компилятору вывести его[6].
    ```java
    printArray(intArray); // Выведет: 1 2 3
    printArray(strArray); // Выведет: Hello World
    ```

**Ограничение типа сверху**

1.  **Ключевое слово `extends`:** Ограничение сверху указывает, что тип должен быть подклассом указанного класса или интерфейса[5].
    ```java
    public static <T extends Number> byte asByte(T num) {
        long n = num.longValue();
        if (n >= -128 && n <= 127) return (byte)n;
        else return 0;
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть подклассом класса `Number`[5]. Это позволяет использовать метод `doubleValue()` для преобразования значения объектов типа `T` в тип `double`[6].

**Ограничение типа снизу**

1.  **Ключевое слово `super`:** Ограничение снизу указывает, что тип должен быть суперклассом указанного класса[5].
    ```java
    public static <T super Integer> void processElements(List<T> list) {
        // ...
    }
    ```
2.  **Пример:** В этом примере тип `T` должен быть суперклассом класса `Integer`. Это позволяет методу работать со списками, которые могут содержать `Integer` или его суперклассы.


**Вопрос 3**

Класс **Number** в Java — это абстрактный суперкласс для всех числовых классов-оберток, таких как Integer, Double, Float, Long, Byte и Short. Он определяет методы для преобразования числовых значений в разные примитивные типы: `byteValue()`, `doubleValue()`, `floatValue()`, `intValue()`, `longValue()`, `shortValue()`[2].

**Классы-обертки (Wrappers)** — это классы, которые "оборачивают" примитивные типы данных в объекты. Например:
- `Integer` — обертка для `int`
- `Double` — обертка для `double`
- `Character` — обертка для `char`
- `Boolean` — обертка для `boolean`

Эти классы позволяют использовать примитивы там, где необходимы объекты, например, в коллекциях.

**Автоупаковка (autoboxing)** — это автоматическое преобразование примитивного типа в соответствующий объект-обертку. Например, при присваивании значения типа `int` переменной типа `Integer` компилятор автоматически создает объект `Integer`.

```java
Integer i = 5; // автоупаковка int в Integer
```

**Автораспаковка (unboxing)** — обратный процесс, когда объект-обертка автоматически преобразуется в примитивный тип.

```java
int n = i; // автораспаковка Integer в int
```

Таким образом, автоупаковка и автораспаковка упрощают работу с примитивами и объектами, устраняя необходимость явного создания объектов-оберток или вызова методов для получения примитивных значений[2].

Важной особенностью является то, что все классы-обертки наследуются от `Number` (кроме `Character` и `Boolean`, которые не являются числовыми), что позволяет использовать их в обобщениях и методах с ограничениями по типу, например `<T extends Number>`[2][6].

**Вопрос 4**

В Java коллекции представляют собой структуры данных для хранения и управления группами однородных элементов. Основные виды коллекций и их интерфейсы:

## Виды коллекций и основные интерфейсы

- **List**  
  Упорядоченный список элементов, допускающий дубликаты. Каждый элемент имеет индекс. Позволяет получать, добавлять и удалять элементы по индексу.  
  Основные реализации: `ArrayList`, `LinkedList`, `Vector`.  
  Особенности: поддержка итератора `ListIterator`, который умеет перемещаться вперед и назад по списку.  
  [1][2][7]

- **Set**  
  Коллекция уникальных элементов, не допускающая дубликатов. Порядок элементов не гарантируется (в зависимости от реализации).  
  Основные реализации: `HashSet`, `TreeSet`, `LinkedHashSet`.  
  [1][2]

- **Queue**  
  Коллекция, работающая по принципу «первым пришел — первым вышел» (FIFO). Используется для организации очередей.  
  Основные реализации: `LinkedList`, `PriorityQueue`.  
  [1][2]

- **Deque**  
  Расширяет интерфейс `Queue` и представляет двунаправленную очередь, где элементы можно добавлять и удалять с обоих концов.  
  Основные реализации: `ArrayDeque`, `LinkedList`.  
  [2]

- **Map**  
  Коллекция пар «ключ-значение», где ключи уникальны. Не наследуется от `Collection`, но тесно связана с коллекциями.  
  Основные реализации: `HashMap`, `TreeMap`, `LinkedHashMap`.  
  [1][2][5]

## Иерархия и особенности

- Интерфейс `Collection` — базовый для `List`, `Set` и `Queue`.  
- Интерфейс `Iterable` — корневой для всех коллекций, обеспечивает возможность перебора элементов.  
- `Map` не входит в иерархию `Collection`, но является ключевой структурой данных для хранения ассоциативных пар.  
[2][5][6]

## Краткое сравнение

| Интерфейс | Описание                          | Особенности                          | Примеры реализаций          |
|-----------|---------------------------------|------------------------------------|----------------------------|
| List      | Упорядоченный список с дубликатами | Индексированный доступ, дубликаты разрешены | ArrayList, LinkedList, Vector |
| Set       | Множество уникальных элементов   | Нет дубликатов, порядок не гарантируется | HashSet, TreeSet, LinkedHashSet |
| Queue     | Очередь FIFO                    | Добавление в конец, удаление из начала | LinkedList, PriorityQueue   |
| Deque     | Двунаправленная очередь          | Добавление/удаление с обоих концов | ArrayDeque, LinkedList      |
| Map       | Коллекция пар ключ-значение      | Уникальные ключи, быстрый поиск по ключу | HashMap, TreeMap, LinkedHashMap |

Таким образом, выбор коллекции зависит от требований к упорядочиванию, уникальности элементов и способу доступа к данным. Коллекции в Java обеспечивают гибкие и эффективные инструменты для работы с различными структурами данных.  
[1][2][5][6][7]

**Вопрос 5**

Для обхода элементов коллекций в Java используются интерфейсы **Iterable**, **Iterator** и **ListIterator**, которые обеспечивают последовательный доступ к элементам без раскрытия внутренней структуры коллекции.

## Интерфейс Iterable

- Это базовый интерфейс, реализуемый всеми коллекциями, который позволяет получить итератор для обхода элементов.  
- Определяет метод `iterator()`, возвращающий объект типа `Iterator`.  
- Позволяет использовать цикл `for-each` для удобного перебора элементов коллекции.

## Интерфейс Iterator

- Предоставляет методы для последовательного обхода коллекции:  
  - `boolean hasNext()` — проверяет, есть ли следующий элемент;  
  - `E next()` — возвращает следующий элемент;  
  - `void remove()` — удаляет текущий элемент из коллекции (после вызова `next()`).  
- Итератор позволяет безопасно проходить по коллекции, получать и удалять элементы во время обхода.  
- Получается через метод `iterator()` коллекции.  
- Пример использования:
  ```java
  Iterator<String> it = collection.iterator();
  while (it.hasNext()) {
      String element = it.next();
      System.out.println(element);
  }
  ```

## Интерфейс ListIterator

- Расширяет `Iterator` и предназначен для обхода списков (`List`).  
- Добавляет возможность двунаправленной итерации:  
  - `boolean hasPrevious()` и `E previous()` — для движения назад по списку;  
- Позволяет получать индексы элементов:  
  - `int nextIndex()`, `int previousIndex()`;  
- Поддерживает изменение коллекции во время обхода:  
  - `void add(E e)` — вставка элемента;  
  - `void set(E e)` — замена текущего элемента;  
  - `void remove()` — удаление текущего элемента;  
- Получается через метод `listIterator()` списка.  
- Пример двунаправленного обхода:
  ```java
  ListIterator<String> listIt = list.listIterator();
  while (listIt.hasNext()) {
      System.out.println(listIt.next());
  }
  while (listIt.hasPrevious()) {
      System.out.println(listIt.previous());
  }
  ```

Таким образом, интерфейс **Iterable** обеспечивает получение итератора, **Iterator** позволяет последовательно обходить и изменять коллекцию, а **ListIterator** расширяет эти возможности для списков, предоставляя двунаправленную навигацию и дополнительные методы модификации элементов[1][2][3][4][7].

**Вопрос 6**

Для сортировки элементов коллекций в Java используются интерфейсы **Comparable** и **Comparator**, которые задают правила сравнения объектов.

## Интерфейс Comparable

- Определяет естественный порядок сортировки объектов класса.  
- Класс, объекты которого нужно сортировать, должен реализовать интерфейс `Comparable<T>` и переопределить метод:
  ```java
  int compareTo(T o);
  ```
- Метод `compareTo` возвращает отрицательное число, ноль или положительное число, если текущий объект меньше, равен или больше объекта `o`.  
- Пример:
  ```java
  public class Person implements Comparable<Person> {
      private int age;
      @Override
      public int compareTo(Person other) {
          return Integer.compare(this.age, other.age);
      }
  }
  ```
- Используется, когда сортировка всегда должна происходить по одному критерию — "естественному порядку".  
- Коллекции, такие как `TreeSet` и `TreeMap`, требуют реализации `Comparable` для автоматической сортировки элементов[1][2][5].

## Интерфейс Comparator

- Позволяет задавать альтернативные или дополнительные правила сортировки, не изменяя исходный класс.  
- Реализуется в отдельном классе или с помощью лямбда-выражений.  
- Определяет метод:
  ```java
  int compare(T o1, T o2);
  ```
- Позволяет сортировать по разным атрибутам или нескольким критериям, комбинируя компараторы через `thenComparing`.  
- Пример сортировки по имени и отделу:
  ```java
  Collections.sort(students, Comparator.comparing(Student::getDepartment)
                                       .thenComparing(Student::getName));
  ```
- Можно создавать компараторы "на лету" через статический метод `Comparator.comparing()` и использовать методы для обработки `null` и обратного порядка.  
- Обеспечивает гибкость и расширяемость сортировки без изменения класса объектов[1][3][6].

## Итоги и рекомендации

| Особенность               | Comparable                         | Comparator                          |
|--------------------------|----------------------------------|-----------------------------------|
| Где реализуется           | В самом классе                   | В отдельном классе или лямбдами   |
| Количество критериев      | Один (естественный порядок)      | Несколько, комбинируемые          |
| Изменение исходного класса| Требуется                       | Не требуется                      |
| Использование             | Для коллекций с естественным порядком | Для гибкой и многоуровневой сортировки |

Таким образом, если нужна простая сортировка по одному критерию — реализуйте `Comparable`. Если требуется несколько вариантов сортировки или сложная логика — используйте `Comparator`[1][2][3][6].

**Вопрос 7**

Интерфейс **List** в Java представляет собой упорядоченную коллекцию, которая допускает хранение дубликатов и обеспечивает доступ к элементам по индексу. Он расширяет интерфейс **Collection** и добавляет методы для работы с позициями элементов, такие как вставка, замена, сортировка и получение подсписков[3][5][8].

## Интерфейс List

- Хранит элементы в порядке добавления.
- Позволяет обращаться к элементам по индексу.
- Поддерживает дубликаты.
- Основные методы:  
  - `add(int index, E element)` — вставка элемента по индексу;  
  - `set(int index, E element)` — замена элемента по индексу;  
  - `get(int index)` — получение элемента по индексу;  
  - `subList(int start, int end)` — получение подсписка;  
  - `sort(Comparator<? super E> c)` — сортировка списка.

## Класс ArrayList

- Реализация интерфейса List на основе динамического массива.  
- Позволяет быстро получать доступ к элементам по индексу (операция за O(1)).  
- При добавлении элементов в конец может расширять внутренний массив (копирование данных при увеличении размера).  
- Медленнее при вставке и удалении элементов в середине списка, так как требует сдвига элементов.  
- Поддерживает хранение любых ссылочных типов, включая `null`.  
- Часто используется благодаря хорошему балансу производительности и удобству.  
- Конструкторы:  
  - `ArrayList()` — с начальной емкостью 10;  
  - `ArrayList(int initialCapacity)` — с заданной емкостью;  
  - `ArrayList(Collection<? extends E> c)` — создание из другой коллекции[2][3][6].

## Класс LinkedList

- Реализация интерфейса List на основе двусвязного списка.  
- Позволяет эффективно вставлять и удалять элементы в любом месте списка (операции за O(1), если известна позиция).  
- Медленнее при доступе по индексу, так как требует последовательного обхода (операция за O(n)).  
- Также реализует интерфейс Queue и Deque, позволяя использовать его как очередь или двунаправленную очередь.  
- Подходит, когда требуется много вставок и удалений, а быстрый доступ по индексу не критичен[7][8].

## Сравнение ArrayList и LinkedList

| Характеристика           | ArrayList                          | LinkedList                      |
|-------------------------|----------------------------------|--------------------------------|
| Основная структура       | Динамический массив               | Двусвязный список              |
| Доступ по индексу        | Быстрый (O(1))                   | Медленный (O(n))               |
| Вставка/удаление в середине | Медленная (сдвиг элементов)      | Быстрая (перенастройка ссылок)|
| Использование памяти     | Меньше (массив)                  | Больше (узлы с указателями)    |
| Дополнительные интерфейсы| Нет                             | Реализует Queue и Deque        |

## Рекомендации по использованию

- Используйте **ArrayList**, если требуется быстрый доступ по индексу и операции вставки/удаления преимущественно в конце списка.  
- Используйте **LinkedList**, если часто выполняются вставки и удаления в середине коллекции и не важен быстрый доступ по индексу.

## Пример создания и использования ArrayList

```java
List<String> list = new ArrayList<>();
list.add("яблоко");
list.add("банан");
list.add("вишня");
System.out.println(list.get(1)); // банан
```

Таким образом, интерфейс **List** обеспечивает удобную работу с упорядоченными коллекциями, а классы **ArrayList** и **LinkedList** предоставляют разные реализации, оптимизированные под разные сценарии использования[2][3][7][8].



**Вопрос 8**

Интерфейсы **Map** и **SortedMap** в Java представляют коллекции пар «ключ-значение», но отличаются по функциональности и способу хранения данных.

## Интерфейс Map

- Представляет коллекцию пар «ключ-значение», где каждому ключу сопоставлено одно значение.  
- Ключи уникальны, значения могут повторяться.  
- Не наследуется от `Collection`, но является частью Java Collections Framework.  
- Основные методы:  
  - `put(K key, V value)` — добавить или заменить пару;  
  - `get(Object key)` — получить значение по ключу;  
  - `containsKey(Object key)` — проверить наличие ключа;  
  - `remove(Object key)` — удалить пару по ключу;  
  - `entrySet()` — получить набор пар `Map.Entry<K,V>` для перебора.  

## Интерфейс SortedMap

- Расширяет интерфейс `Map`.  
- Гарантирует, что элементы хранятся в отсортированном порядке по ключам (естественный порядок или с помощью `Comparator`).  
- Добавляет методы для работы с диапазонами ключей и навигации:  
  - `firstKey()`, `lastKey()` — получить первый и последний ключ;  
  - `headMap(K toKey)`, `tailMap(K fromKey)`, `subMap(K fromKey, K toKey)` — получить части отображения по диапазонам ключей;  
  - `comparator()` — получить используемый компаратор (или `null`, если используется естественный порядок).  

## Класс HashMap

- Реализация интерфейса `Map` на основе хэш-таблицы.  
- Обеспечивает быстрый доступ, вставку и удаление элементов (в среднем за O(1)).  
- Не гарантирует порядок элементов.  
- Позволяет один `null` ключ и несколько `null` значений.  
- Подходит для большинства задач, где порядок не важен, а нужна высокая производительность.

## Класс TreeMap

- Реализация интерфейса `SortedMap` (а также `NavigableMap`) на основе красно-черного дерева.  
- Хранит элементы в отсортированном порядке по ключам.  
- Операции вставки, удаления и поиска выполняются за O(log n).  
- Требует, чтобы ключи были сравнимы (реализовали `Comparable`) или чтобы при создании передавался `Comparator`.  
- Предоставляет расширенный функционал навигации по ключам: поиск ближайших ключей, удаление первого/последнего элемента и др.  
- Используется, когда важен отсортированный порядок ключей и возможность работы с диапазонами.

## Итоговое сравнение

| Характеристика       | HashMap                         | TreeMap                          |
|---------------------|--------------------------------|---------------------------------|
| Интерфейс           | Map                            | SortedMap, NavigableMap          |
| Структура данных    | Хэш-таблица                    | Красно-черное дерево             |
| Порядок элементов   | Не гарантируется               | Отсортирован по ключам           |
| Сложность операций  | O(1) в среднем                 | O(log n)                        |
| Поддержка null      | Ключ — 1 null, значения — несколько | Ключи null не поддерживаются    |
| Дополнительные методы| Нет                           | Методы работы с диапазонами и навигации по ключам |

Таким образом, **HashMap** — это быстрая и простая реализация для хранения пар без порядка, а **TreeMap** — для случаев, когда важен отсортированный порядок ключей и расширенные возможности навигации.

---



**Вопрос 9**

В Java интерфейсы `Set` и `SortedSet` используются для представления наборов уникальных элементов, при этом `SortedSet` дополнительно обеспечивает их упорядочивание. `HashSet` и `TreeSet` — это классы, реализующие эти интерфейсы[9].

**Интерфейс Set**
*   Представляет собой набор уникальных элементов, не допускающий дублирования[3][4].
*   Не добавляет новых методов, а изменяет унаследованные, например, метод `add()` возвращает `true`, только если элемент еще не содержится в коллекции[3][4].
*   Реализован классами `HashSet`, `TreeSet` и `LinkedHashSet`[9].

**Интерфейс SortedSet**
*   Расширяет интерфейс `Set` и представляет собой упорядоченное множество, элементы которого отсортированы по возрастанию или в соответствии с `Comparator`[6].
*   Содержит методы для работы с упорядоченными данными, такие как `comparator()`, `first()`, `last()`, `headSet()`, `subSet()`, `tailSet()`[6].

**Класс HashSet**
*   Реализует интерфейс `Set` и хранит элементы в хеш-таблице[1][4].
*   Не гарантирует порядок элементов при переборе[1][2].
*   Может хранить `NULL` значения[2].
*   Для создания объекта `HashSet` можно использовать следующие конструкторы[3]:
    *   `HashSet()`: создает пустой список.
    *   `HashSet(Collection<? extends E> col)`: создает хеш-таблицу, добавляя все элементы из указанной коллекции.
    *   `HashSet(int capacity)`: создает хеш-таблицу с указанной начальной емкостью (по умолчанию 16).
    *   `HashSet(int capacity, float koef)`: создает хеш-таблицу с указанной начальной емкостью и коэффициентом заполнения (от 0.0 до 1.0).

**Класс TreeSet**
*   Реализует интерфейс `SortedSet` и хранит элементы в отсортированном порядке[6].
*   Элементы хранятся в отсортированном порядке по возрастанию[6].
*   Операции удаления и вставки выполняются медленнее, чем в `HashSet`, но быстрее, чем в списках[6].
*   Реализует интерфейс `NavigableSet`[8].
*   Конструкторы класса `TreeSet`[6]:
    *   `TreeSet()`
    *   `TreeSet(Collection<? extends Е> сollection)`
    *   `TreeSet(Comparator<? super Е> соmрarator)`
    *   `TreeSet(SortedSet<E> sortedSet)`

Как вы изучаете структуры данных в Java[10], важно понимать, как `HashSet` и `TreeSet` реализуют интерфейсы `Set` и `SortedSet`[9].



**Вопрос 10**

В Java интерфейсы `Queue` и `Deque` являются частью Collections Framework и предоставляют способы хранения и управления элементами в определенном порядке[4][5]. Классы `PriorityQueue` и `ArrayDeque` являются реализациями этих интерфейсов.

**Интерфейс Queue**
*   Представляет собой коллекцию, предназначенную для хранения элементов в порядке "первым пришел — первым вышел" (FIFO)[4][5].
*   Определяет методы для добавления (`add()`, `offer()`), удаления (`remove()`, `poll()`) и просмотра (`element()`, `peek()`) элементов[5][6].
*   `Queue` является однонаправленной очередью, где элементы добавляются в конец, а извлекаются из начала[1].

**Интерфейс Deque**
*   Расширяет интерфейс `Queue` и представляет собой двустороннюю очередь, позволяющую добавлять и удалять элементы с обоих концов[2][4].
*   Поддерживает как FIFO, так и LIFO (стек) операции[4][5].
*   Предоставляет методы для добавления (`addFirst()`, `addLast()`, `offerFirst()`, `offerLast()`), удаления (`removeFirst()`, `removeLast()`, `pollFirst()`, `pollLast()`) и просмотра (`getFirst()`, `getLast()`, `peekFirst()`, `peekLast()`) элементов с обеих сторон[1][5][7].
*   `Deque` не имеет явно выраженного конца и начала и может расти и уменьшаться в обоих направлениях[8].

**Класс PriorityQueue**
*   Реализует интерфейс `Queue`[6].
*   Представляет собой очередь с приоритетами, где элементы упорядочены в соответствии с их приоритетом[6].
*   Основан на структуре данных "двоичная куча", обеспечивающей быструю вставку и удаление элементов за \$$ O(log n) \$$[6].
*   Удаляет элемент с наивысшим приоритетом (наименьший элемент, если не задан компаратор)[6].
*   Для определения приоритета элементов можно использовать `Comparator`[6].

**Класс ArrayDeque**

*   Реализует интерфейс `Deque`[6].
*   Реализован на основе массива, что делает его эффективным для использования в качестве стека или очереди[6].
*   Поддерживает добавление и удаление элементов с обоих концов за константное время[6].
*   `LinkedList` и `ArrayDeque` напрямую наследуют от `Deque`, а не от `Queue`[3].

Поскольку вас интересует объектно-ориентированное программирование и Java [9][10], важно понимать, как эти интерфейсы и классы реализуют принципы полиморфизма и абстракции.

**Вопрос 11**

В Java 21 появились новые интерфейсы для работы с упорядоченными коллекциями: `SequencedCollection` и `SequencedSet`[1][2][3].

**Интерфейс SequencedCollection**
*   Расширяет интерфейс `Collection`, добавляя методы для манипуляции с первым и последним элементами, а также для инвертирования коллекции[1][2][5].
*   Поддерживает операции как в начале, так и в конце списка, и является обратимой[3].
*   Определяет порядок элементов, располагая их линейно от первого до последнего[3].
*   Содержит методы: `addFirst()`, `addLast()`, `getFirst()`, `getLast()`, `removeFirst()`, `removeLast()`, `reversed()`[2].

Реализации `SequencedCollection`:
*   `List` (`ArrayList` и `LinkedList`)[1][2]
*   `Deque`
*   `SequencedSet`[8]

**Интерфейс SequencedSet**
*   Является под интерфейсом `SequencedCollection`[1].
*   Переопределяет метод `reversed()`, возвращая `SequencedSet` вместо `SequencedCollection`[1].

Реализации `SequencedSet`:
*   `LinkedHashSet` (сохраняет порядок добавления)[1]
*   `TreeSet` (сортирует в алфавитном порядке)[1]

**Класс HashSet**
*   Не поддерживает интерфейс `SequencedSet`, так как не обеспечивает порядок[1].

**Класс LinkedHashSet**
*   Реализует интерфейс `SequencedSet` и сохраняет порядок добавления элементов[1].
*   Поддерживает методы `addFirst()` и `addLast()`[1].

**Класс TreeSet**
*   Реализует интерфейс `SequencedSet` и сортирует элементы в алфавитном порядке[1].
*   Не поддерживает методы `addFirst()` и `addLast()`, так как сам определяет порядок элементов[1].
*   Поддерживает удаление первого и последнего элемента[1].

Поскольку вы интересуетесь объектно-ориентированным программированием и Java[9][10], важно понимать, как эти новые интерфейсы расширяют возможности работы с коллекциями, особенно с учетом вашего интереса к интерфейсам и очередям[11].


**Вопрос 12**

В Java классы `Collections`, `Arrays` и `Objects` предоставляют набор статических методов для удобной работы с коллекциями, массивами и объектами соответственно.

## Класс Collections
*   Содержит статические методы для работы с коллекциями (`Collection`, `List`, `Set` и др.).
*   Основные методы:
    *   `addAll(Collection<? super T> c, T... elements)` — добавляет все указанные элементы в коллекцию.
    *   `binarySearch(List<? extends Comparable<? super T>> list, T key)` — выполняет бинарный поиск элемента в отсортированном списке.
    *   `copy(List<? super T> dest, List<? extends T> src)` — копирует элементы из одного списка в другой.
    *   `max(Collection<? extends T> coll)` и `min(Collection<? extends T> coll)` — возвращают максимальный и минимальный элемент коллекции согласно естественному порядку.
    *   `reverse(List<?> list)` — изменяет порядок элементов списка на обратный.
    *   `shuffle(List<?> list)` — случайным образом перемешивает элементы списка.
    *   `sort(List<T> list)` — сортирует список по естественному порядку.
    *   `replaceAll(List<T> list, T oldVal, T newVal)` — заменяет все вхождения одного элемента на другой.
*   Методы работают с интерфейсами коллекций, обеспечивая гибкость и переиспользуемость[3][6].

## Класс Arrays
*   Предназначен для работы с массивами примитивных и ссылочных типов.
*   Основные методы:
    *   `sort()` — сортировка массива целиком или его части.
    *   `binarySearch()` — бинарный поиск в отсортированном массиве.
    *   `equals()` — сравнение содержимого двух массивов (поэлементное сравнение).
    *   `deepEquals()` — сравнение многомерных массивов по содержимому.
    *   `toString()` и `deepToString()` — преобразование массива в строку для вывода.
    *   `copyOf()` и `copyOfRange()` — копирование массива или его части.
    *   `compare()` — сравнение двух массивов примитивных типов с возвратом порядка.
    *   `mismatch()` — поиск первого индекса, где массивы отличаются.
*   Методы упрощают выполнение часто повторяющихся операций с массивами[2][4][5][6].

## Класс Objects
*   Предоставляет утилитарные методы для работы с объектами.
*   Основные методы:
    *   `equals(Object a, Object b)` — безопасное сравнение объектов с учетом `null`.
    *   `hashCode(Object o)` — вычисление хеш-кода объекта с защитой от `null`.
    *   `requireNonNull(T obj)` — проверка на `null`, выбрасывает `NullPointerException`, если объект равен `null`.
    *   `toString(Object o)` — возвращает строковое представление объекта или `"null"`.
    *   `compare(T a, T b, Comparator<? super T> c)` — сравнение объектов с использованием компаратора.
*   Используется для безопасной и удобной работы с объектами, особенно при реализации методов `equals()`, `hashCode()` и `toString()`[6].

Таким образом, `Collections` и `Arrays` предоставляют мощные и удобные методы для работы с коллекциями и массивами, обеспечивая сортировку, поиск, сравнение, копирование и другие операции, а `Objects` помогает безопасно управлять объектами и их сравнениями в Java[1][2][3][6].


**Вопрос 13**

В Java потоки ввода-вывода делятся на два основных типа: байтовые и символьные.

## Байтовые потоки
* Работают с данными в виде байтов (8 бит).
* Основные базовые абстрактные классы:
  * `InputStream` — для чтения байтов.
  * `OutputStream` — для записи байтов.
* Популярные потомки:
  * `FileInputStream` и `FileOutputStream` — для работы с файлами.
  * `ByteArrayInputStream` и `ByteArrayOutputStream` — для работы с массивами байтов в памяти.
  * `BufferedInputStream` и `BufferedOutputStream` — для буферизации байтового ввода-вывода.
* Методы:
  * `read()` — чтение байта или массива байтов.
  * `write()` — запись байта или массива байтов.
  * `close()` — закрытие потока.
* Байтовые потоки удобны для работы с бинарными данными (например, изображениями, аудио).

## Символьные потоки
* Работают с символами Unicode (16 бит).
* Основные базовые абстрактные классы:
  * `Reader` — для чтения символов.
  * `Writer` — для записи символов.
* Популярные потомки:
  * `FileReader` и `FileWriter` — для работы с файлами символов.
  * `BufferedReader` и `BufferedWriter` — для буферизации символьного ввода-вывода.
  * `CharArrayReader` и `CharArrayWriter` — для работы с массивами символов.
  * `PrintWriter` — для удобного вывода с методами `print()` и `println()`.
* Методы:
  * `read()` — чтение символа или массива символов.
  * `write()` — запись символа или массива символов.
  * `close()` — закрытие потока.
* Символьные потоки удобны для работы с текстовыми данными с учетом кодировок.

## Мосты между байтовыми и символьными потоками
* `InputStreamReader` — преобразует байтовый поток `InputStream` в символьный `Reader`, учитывая кодировку.
* `OutputStreamWriter` — преобразует символьный поток `Writer` в байтовый `OutputStream`.
* Позволяют работать с текстом в нужной кодировке (например, UTF-8, Cp1251).

## Итог
| Тип потока       | Базовый класс     | Основные потомки                   | Назначение                      |
|------------------|-------------------|----------------------------------|--------------------------------|
| Байтовый поток   | InputStream / OutputStream | FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream | Работа с бинарными данными      |
| Символьный поток | Reader / Writer   | FileReader, FileWriter, BufferedReader, BufferedWriter, PrintWriter | Работа с текстовыми данными (Unicode) |

Таким образом, байтовые потоки оперируют с сырыми байтами, а символьные — с символами Unicode, обеспечивая удобство работы с текстом и кодировками. Для преобразования между ними используются классы-мосты `InputStreamReader` и `OutputStreamWriter`[1][2][3][5][6][7][8].


**Вопрос 14**

В Java потоки-фильтры — это специальные классы, которые принимают в конструкторе другой поток и оборачивают его, добавляя дополнительную функциональность, например, буферизацию, преобразование или форматирование данных[2][6].

## Потоки-фильтры

* Потоки-фильтры принимают в конструкторе исходный поток и преобразуют или дополняют его поведение.
* Они позволяют строить цепочки потоков, комбинируя разные операции ввода-вывода.
* Пример: буферизация, преобразование байтов в символы, форматированный вывод.

## Класс BufferedReader

* Является потомком `Reader` и представляет собой поток-фильтр для символьного ввода.
* Буферизует данные, считывая сразу большой блок символов из базового потока, что повышает производительность при последовательном чтении.
* Не преобразует байты в символы — для этого нужен `InputStreamReader`.
* Позволяет читать данные построчно с помощью метода `readLine()`.
* Обычно создаётся как обёртка над `InputStreamReader` или другим `Reader`, например:
  ```java
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  ```
* При закрытии `BufferedReader` автоматически закрывается и вложенный поток[3][7][8].

## Класс InputStreamReader

* Является мостом между байтовыми и символьными потоками.
* Наследуется от `Reader`.
* Преобразует байты из `InputStream` в символы с учётом заданной кодировки (по умолчанию — системная).
* Используется для чтения текстовых данных из байтовых источников, например, из консоли или файла.
* Пример использования:
  ```java
  InputStreamReader isr = new InputStreamReader(System.in, "UTF-8");
  ```
* Часто используется в связке с `BufferedReader` для эффективного и удобного чтения текста[2][7][8].

## Класс PrintStream

* Реализует байтовый поток вывода (`OutputStream`).
* Предназначен для вывода данных на консоль, в файл или другой байтовый источник.
* Поддерживает буферизацию и автоматический сброс буфера (например, при вызове `println()`).
* Позволяет выводить данные в текстовом формате с удобными методами `print()` и `println()`.
* В Java стандартный поток вывода `System.out` — это объект класса `PrintStream`.
* Может использоваться для вывода с заданной кодировкой через обёртки, например, `OutputStreamWriter`.
* Конструктор с параметром `autoFlush` позволяет автоматически сбрасывать буфер после вызова методов вывода строк[2][7].

---

Таким образом, `InputStreamReader` преобразует байты в символы, `BufferedReader` буферизует символы и предоставляет удобное чтение строк, а `PrintStream` обеспечивает удобный и буферизованный вывод байтов, часто используемый для вывода на консоль. Все они являются важными элементами цепочек потоков-фильтров в Java.


**Вопрос 15**

В Java стандартный ввод и вывод представлены тремя предопределёнными потоками в классе `System`:

- **`System.in`** — стандартный поток ввода, по умолчанию связанный с клавиатурой. Это объект типа `InputStream`, который читает байты с консоли. Для удобного чтения текстовых данных его обычно оборачивают в классы, например, `Scanner` или `BufferedReader` через `InputStreamReader`[1][2][4][6].

- **`System.out`** — стандартный поток вывода, по умолчанию связанный с консолью. Это объект класса `PrintStream`, который позволяет выводить данные в текстовом формате с помощью методов `print()`, `println()` и др. Можно перенаправлять вывод в файлы или другие потоки[2][4][5].

- **`System.err`** — стандартный поток вывода ошибок, также связанный с консолью. Используется для вывода сообщений об ошибках и предупреждениях. В отличие от `System.out`, поток `System.err` обычно не буферизуется, поэтому вывод ошибок отображается сразу[2][3].

---

### Класс Scanner

* Предназначен для удобного чтения данных из различных источников, включая стандартный ввод (`System.in`).
* Поддерживает чтение различных типов данных: строки (`nextLine()`), целые числа (`nextInt()`), числа с плавающей точкой, логические значения и др.
* Для работы со стандартным вводом создаётся так:
  ```java
  Scanner scanner = new Scanner(System.in);
  String line = scanner.nextLine();
  int number = scanner.nextInt();
  ```
* Позволяет удобно парсить входные данные по пробелам, переходам строк и другим разделителям[1][6].

---

Таким образом, для ввода с клавиатуры используется `System.in`, который часто оборачивают в `Scanner` для удобного чтения, а для вывода на консоль — `System.out` (обычно `PrintStream`), а для ошибок — `System.err`. Эти потоки являются стандартными и доступны через статические поля класса `System`.


**Вопрос 16**

В Java **сериализация объектов** — это процесс преобразования объекта в последовательность байтов для сохранения в файл, передачи по сети или кэширования, с возможностью последующего восстановления объекта (десериализации).

## Интерфейс Serializable

* `Serializable` — это **маркерный интерфейс**, который не содержит методов и служит для обозначения класса как сериализуемого[2][4].
* Чтобы объект можно было сериализовать, класс должен реализовать этот интерфейс.
* Все поля объекта также должны быть сериализуемыми (примитивные типы сериализуются по умолчанию).
* Если класс наследуется от несериализуемого суперкласса, у того должен быть конструктор без аргументов[2].
* Для сериализации используется класс `ObjectOutputStream`, для десериализации — `ObjectInputStream`[3][5].

## Модификатор transient

* Поля, объявленные с модификатором `transient`, **исключаются из процесса сериализации**[1][2][4].
* Это полезно для полей, которые не должны сохраняться, например, временные данные, ссылки на ресурсы, которые нельзя или не нужно сериализовать.
* При десериализации такие поля получают значение по умолчанию (например, `null` для объектов, `0` для чисел).
* При необходимости можно самостоятельно сериализовать и десериализовать `transient` поля, реализовав методы `writeObject(ObjectOutputStream out)` и `readObject(ObjectInputStream in)`[2][4].

---

### Пример использования Serializable и transient

```java
import java.io.Serializable;

public class Target implements Serializable {
    private int intField;
    private String strField;
    private transient int transientField; // не сериализуется

    public Target(int i, String s, int trn) {
        this.intField = i;
        this.strField = s;
        this.transientField = trn;
    }

    @Override
    public String toString() {
        return "Target{" +
               "intField=" + intField +
               ", strField='" + strField + '\'' +
               ", transientField=" + transientField +
               '}';
    }
}
```

При сериализации объекта `Target` поле `transientField` не будет сохранено, и после десериализации оно будет иметь значение по умолчанию (0)[2][4].

---

Таким образом, интерфейс `Serializable` позволяет отмечать классы для сериализации, а модификатор `transient` исключает отдельные поля из этого процесса, что даёт гибкость при сохранении состояния объектов.



**Вопрос 17**

В Java для работы с файлами используются несколько ключевых классов и интерфейсов, которые обеспечивают удобное и современное управление файловой системой.

## Интерфейс Path

* `Path` — это интерфейс из пакета `java.nio.file`, который является современным и более удобным аналогом класса `File`.
* Представляет путь к файлу или директории как последовательность элементов (папок и имени файла).
* Методы `Path` возвращают объекты типа `Path`, что упрощает работу с путями и исключает неоднозначность, свойственную классу `File` (где методы могли возвращать разные типы — строки, boolean или объекты `File`).
* Позволяет легко получать имя файла (`getFileName()`), родительский путь (`getParent()`), количество элементов пути (`getNameCount()`), подпути (`subpath()`), преобразовывать путь в строку (`toString()`) и др.
* Пример создания пути:
  ```java
  Path p1 = Paths.get("/foo/bar");
  Path p2 = Paths.get(URI.create("file:///foo/bar/Main.java"));
  ```

## Класс Paths

* Утилитный класс с статическими методами для создания объектов `Path`.
* Основные методы:
  * `Paths.get(String first, String... more)` — создает объект `Path` из одного или нескольких компонентов пути.
  * `Paths.get(URI uri)` — создает `Path` из URI.
* Используется для получения объекта `Path` для дальнейших операций.

## Класс File

* Более старый класс из пакета `java.io`, который работает с файлами и директориями.
* Позволяет получать информацию о файле (путь, права доступа, дата создания), создавать и удалять файлы и каталоги.
* Методы возвращают разные типы (например, `String`, `boolean`, `File`), что усложняет использование.
* Пример создания файла:
  ```java
  File file = new File("example.txt");
  ```
* Поддерживает навигацию по файловой системе, но менее удобен и функционален по сравнению с `Path` и `Files`.

## Класс Files

* Утилитный класс из пакета `java.nio.file`, содержащий множество статических методов для работы с файлами и директориями.
* Работает с объектами `Path`.
* Основные методы:
  * `createFile(Path path)` — создает новый файл.
  * `createDirectory(Path path)` — создает новую директорию.
  * `delete(Path path)` — удаляет файл или директорию.
  * `copy(Path source, Path target)` — копирует файл.
  * `move(Path source, Path target, CopyOption... options)` — перемещает или переименовывает файл.
  * `exists(Path path)` — проверяет существование файла или директории.
  * `isDirectory(Path path)` — проверяет, является ли путь директорией.
  * `size(Path path)` — возвращает размер файла.
* Обеспечивает более современный и удобный API для работы с файловой системой по сравнению с классом `File`.

---

### Итоговое сравнение

| Класс / Интерфейс | Назначение                              | Особенности и примеры использования                          |
|-------------------|---------------------------------------|-------------------------------------------------------------|
| `Path`            | Интерфейс для представления пути      | Современный способ работы с путями, возвращает объекты Path |
| `Paths`           | Утилитный класс для создания Path     | Статические методы `get()` для создания объектов Path       |
| `File`            | Класс для работы с файлами и каталогами | Старый класс, методы возвращают разные типы, менее удобен   |
| `Files`           | Утилитный класс с методами для файлов | Статические методы для создания, удаления, копирования и др.|

---

Таким образом, современный подход в Java — использовать интерфейс `Path` для представления путей, класс `Paths` для их создания и класс `Files` для выполнения операций с файлами и директориями, что обеспечивает более чистый и удобный API по сравнению с классом `File`[1][2][4][5][6][7].



**Вопрос 18**

Новый пакет ввода-вывода в Java называется NIO (New Input/Output) и предоставляет более эффективный и гибкий механизм работы с данными по сравнению с классическими потоками. Основными элементами этого пакета являются буферы и каналы.

## Буферы и каналы в Java NIO

- **Буферы (Buffers)** — это контейнеры для данных одного примитивного типа (чаще всего байтов). Они используются для временного хранения данных при операциях ввода-вывода. Буферы бывают двух типов: direct (прямой доступ к памяти, используемой устройством) и non-direct (память синхронизируется с памятью устройства)[8].

- **Каналы (Channels)** — это объекты, которые обеспечивают двунаправленный доступ к источнику или приемнику данных. Каналы могут читать и писать данные в буферы. Основные типы каналов в Java NIO:
  - FileChannel — для работы с файлами,
  - DatagramChannel — для передачи датаграмм,
  - SocketChannel — для сетевого ввода-вывода,
  - ServerSocketChannel — для установки сетевых соединений[8][9].

Каналы являются более эффективной альтернативой потокам, так как позволяют работать с данными напрямую через буферы и поддерживают операции позиционирования, блокировки и передачи данных между каналами.

## Класс FileChannel

`FileChannel` — это канал для чтения, записи, отображения и управления файлами. Он реализует интерфейс `SeekableByteChannel`, что позволяет перемещаться по файлу, читать и записывать данные в произвольных позициях[2][5].

### Основные возможности FileChannel:

- Чтение и запись данных в файл с возможностью указания позиции,
- Получение и установка текущей позиции в файле,
- Получение размера файла,
- Отображение части файла в память (memory-mapped files) через метод `map()`,
- Передача данных напрямую между каналами (например, для копирования файлов),
- Блокировка частей файла для синхронизации доступа из разных потоков,
- Принудительная запись данных на диск для предотвращения потери данных[5][6].

### Работа с FileChannel

Для открытия канала используется, например, класс `RandomAccessFile` или потоки `FileInputStream`/`FileOutputStream` с вызовом метода `getChannel()`:

```java
RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
FileChannel channel = file.getChannel();
```

Чтение данных осуществляется через буфер `ByteBuffer`:

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);
```

Позиция чтения/записи может быть получена и изменена:

```java
long position = channel.position();
channel.position(5);
```

Размер файла можно получить методом `size()`:

```java
long size = channel.size();
```

### Преимущества FileChannel

- Возможность позиционированного доступа к файлу,
- Эффективная работа с большими файлами через memory-mapped buffers,
- Высокая производительность при передаче данных между каналами,
- Поддержка блокировок для многопоточного доступа[5].

Таким образом, новый пакет ввода-вывода Java NIO с классом `FileChannel` и буферами предоставляет мощный и гибкий инструмент для эффективной работы с файлами и другими источниками данных, превосходящий по возможностям классические потоки ввода-вывода[1][5][6][8].


